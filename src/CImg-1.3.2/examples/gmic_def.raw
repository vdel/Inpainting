#@gmic
#
#  File        : gmic_def.raw
#                ( G'MIC default custom commands )
#
#  Description : Define recognized commands for the G'MIC interpreter
#                and available filters for GIMP plug-in.
#                ( http://gmic.sourceforge.net )
#
#                This file is also a part of the CImg Library project.
#                ( http://cimg.sourceforge.net )
#
#  Usage       : gmic [-m gmic_def.raw] (...)
#
#  Note        : This file is only here for illustration purposes : all commands
#                defined here are already present by default in G'MIC.
#                Explicit inclusion of this file (using the '-m' option) is
#                then useless.
#
#  Copyright   : David Tschumperle
#                ( http://www.greyc.ensicaen.fr/~dtschump/ )
#
#  License     : CeCILL v2.0
#                ( http://www.cecill.info/licences/Licence_CeCILL_V2-en.html )
#
#  This software is governed by the CeCILL  license under French law and
#  abiding by the rules of distribution of free software.  You can  use,
#  modify and/ or redistribute the software under the terms of the CeCILL
#  license as circulated by CEA, CNRS and INRIA at the following URL
#  "http://www.cecill.info".
#
#  As a counterpart to the access to the source code and  rights to copy,
#  modify and redistribute granted by the license, users are provided only
#  with a limited warranty  and the software's author,  the holder of the
#  economic rights,  and the successive licensors  have only  limited
#  liability.
#
#  In this respect, the user's attention is drawn to the risks associated
#  with loading,  using,  modifying and/or developing or reproducing the
#  software by the user in light of its specific status of free software,
#  that may mean  that it is complicated to manipulate,  and  that  also
#  therefore means  that it is reserved for developers  and  experienced
#  professionals having in-depth computer knowledge. Users are therefore
#  encouraged to load and test the software's suitability as regards their
#  requirements in conditions enabling the security of their systems and/or
#  data to be ensured and,  more generally, to use and operate it in the
#  same conditions as regards security.
#
#  The fact that you are presently reading this means that you have had
#  knowledge of the CeCILL license and that you accept its terms.
#

#--- General syntax rules for a G'MIC command file : ---------------------------------------------------------------------
#
# - Each line starting with '#' is a comment line.
#
# - Each line starting with 'command_name : ' defines the beginning of a new G'MIC custom command.
#
# - Any other line is considered as the continuation of the previous started G'MIC custom command.
#
# - A comment line as '#@gmic command_name : arguments : description' will be used in the command line
#   version of G'MIC as the helper for this command (displayed when invoking 'gmic -help').
#
# - A comment line starting with '#@gimp' will be used to in the GIMP plug-in version of G'MIC to define
#   a new filter entry.
#
# - Same rules apply for comment line starting with '#@gimp_xx' to define filters translated in language
#   'xx' (e.g. 'en','fr'...).
#
#   More precisely, the syntax of a '#@gimp' comment line can be :
#
#   '#@gimp Group name'
#
# or
#
#   '#@gimp Command name : command, preview_command, parameter = typedef, parameter2 = typedef'
#   '#@gimp : parameter3 = typedef, parameter4 = typedef ...., parameterN = typedef'
#
#   where :
#      'command' is the G'MIC command name called to process the image.
#      'preview_command' is the G'MIC command name called to process the preview.
#      'parameter = typedef' tells about the names, types and default values of the filter parameters.
#
#   'typedef' can be :
#
#      - 'float(default_value,min_value,max_value)'       : Add a float-valued parameter (as a GUI float slider).
#      - 'int(default_value,min_value,max_value)'         : Add a integer parameter (as a GUI integer slider).
#      - 'bool(default_value={0,1,false,true})'           : Add a boolean parameter (0 or 1) (as a GUI checkbutton).
#      - 'choice(_default_indice,Choice0,..,ChoiceN)'     : Add a integer parameter (as a GUI combobox).
#      - 'text(_default text)'                            : Add a text parameter (as a GUI text entry).
#      - 'file(_default_filename)'                        : Add a filename parameter (as a GUI filechooser).
#      - 'folder(_default_foldername)'                    : Add a foldername parameter (as a GUI folderchooser).
#      - 'color(defaultR,defaultG,defaultB,_defaultA)'    : Add R,G,B[,A] parameters (as a GUI colorchooser).
#      - 'note(_Comment)'                                 : Display a label, but do not add a new parameter.
#      - 'link(_Comment,URL)'                             : Display a label that link to a specified URL.
#      - 'value(value)'                                   : Do not display a GUI widget, but set a parameter value.
#
#   Type separators '()' can be replaced by '[]' and '{}' if necessary (for instance if parentheses are required in
#   an argument of the typedef, e.g in a text). You can also replace 'typedef' by '_typedef' to tell the plug-in not
#   to update the image preview when the corresponding parameter is modified.
#
#-----------------------------------------------------------------------------------------------------------------------

#--------------------------------
#
# Useful all-purpose commands
#
#--------------------------------

#@gmic apply : '"command",_channels={0=Available,1=RGBA,2=RGB,3=Y,4=CbCr,5=Cb,6=Cr,7=A}' : Apply specified command on chosen channels of selected images.
apply : -skip ${1=-nop},${2=0} -check {"$2>=0 && $2<=7"}
  -v-
  -if {$2==0}
    -v+ -e "Apply command(s) '"$1"' on image$?." -v-
    -_apply $1
  -elif {$2==1}
    -v+ -e "Apply command(s) '"$1"' on RGBA channels of image$?." -v-
    -to_rgba
    -_apply $1
  -elif {$2==2}
    -v+ -e "Apply command(s) '"$1"' on RGB channels of image$?." -v-
    -repeat @# -l[-1]
      -split_opacity -to_rgb[0]
      -_apply[0] $1
      -to_rgb[0] -a c
    -endl -mv[-1] 0 -done
  -elif {$2==3}
    -v+ -e "Apply command(s) '"$1"' on luminance component of image$?." -v-
    -repeat @# -l[-1]
      -split_opacity -to_rgb[0] -rgb2ycbcr[0] -s[0] c
      -_apply[0] $1
      -channels[0] 0 -a[0-2] c -ycbcr2rgb[0] -a c
    -endl -mv[-1] 0 -done
  -elif {$2==4}
    -v+ -e "Apply command(s) '"$1"' on blue/red chrominances of image$?." -v-
    -repeat @# -l[-1]
      -split_opacity -to_rgb[0] -rgb2ycbcr[0] -s[0] c
      -_apply[1] $1 -_apply[2] $1
      -channels[1,2] 0 -a[0-2] c -ycbcr2rgb[0] -a c
    -endl -mv[-1] 0 -done
  -elif {$2==5}
    -v+ -e "Apply command(s) '"$1"' on blue chrominance of image$?." -v-
    -repeat @# -l[-1]
      -split_opacity -to_rgb[0] -rgb2ycbcr[0] -s[0] c
      -_apply[1] $1
      -channels[1] 0 -a[0-2] c -ycbcr2rgb[0] -a c
    -endl -mv[-1] 0 -done
  -elif {$2==6}
    -v+ -e "Apply command(s) '"$1"' on red chrominance of image$?." -v-
    -repeat @# -l[-1]
      -split_opacity -to_rgb[0] -rgb2ycbcr[0] -s[0] c
      -_apply[2] $1
      -channels[2] 0 -a[0-2] c -ycbcr2rgb[0] -a c
    -endl -mv[-1] 0 -done
  -else
    -v+ -e "Apply command(s) '"$1"' on alpha channel of image$?." -v-
    -repeat @# -l[-1]
      -to_rgba -split_opacity
      -_apply[1] $1
      -channels[-1] 0 -a c
    -endl -mv[-1] 0 -done
  -endif
  -v+

_apply : $* -k[0]

#----------------------------------------
#
# Get and display image characteristics
#
#----------------------------------------

#@gmic gradient_norm : : Compute gradient norm of selected images.
gradient_norm :
  -e "Compute gradient norm of image$?."
  -v- -type float -repeat @#
    -gradient[-1] xyz -a[-3--1] c -norm[-1] -sqrt[-1]
  -mv[-1] 0 -done -v+

#@gmic gradient_orientation : '_dimension={1,2,3}' : Compute N-D gradient orientation of selected images.
gradient_orientation : -check {"$1==1 || $1==2 || $1==3"}
  -e "Compute $1-D gradient orientation of image$?."
  -v- -type float -repeat @#
    -if {$1==1} -gradient[-1] x --abs[-1] -+[-1] 1e-8 -/[-2,-1]
    -elif {$1==2} -gradient[-1] xy --sqr[-2--1] -+[-2,-1] -+[-1] 1e-8 -sqrt[-1] -/[-3] [-1] -/[-2,-1]
    -else -gradient[-1] xyz --sqr[-3--1] -+[-3--1] -+[-1] 1e-8 -sqrt[-1] -/[-4,-3] [-1] -/[-2,-1]
    -endif
  -mv[-$1--1] 0 -done -v+

#@gmic gradient2rgb : '_orientation={0|1}' : Compute RGB representation of 2D gradient of selected images.
gradient2rgb : -skip ${1=0}
  -if $1 -e "Compute RGB representation of 2D gradient orientation of image$?."
  -else -e "Compute RGB representation of 2D gradient of image$?." -endif
  -v- -type float -repeat @#
    -norm[-1]
    -if $1 -gradient_orientation[-1] 2 -else -gradient[-1] xy -endif
    -a[-2,-1] c -direction2rgb[-1]
  -mv[-1] 0 -done -v+

#@gmic laplacian : : Compute Laplacian of selected images.
laplacian :
  -e "Compute Laplacian of image $?."
  -v- -type float -repeat @#
    -hessian[-1] xxyyzz -+[-3--1]
  -mv[-1] 0 -done -v+

#@gmic gradient_2derivative : : Compute gradient-directed 2nd derivative of image(s).
gradient_2derivative :
  -e "Compute gradient-directed 2nd derivative of image$?."
  -v- -type float -repeat @#
    --gradient[-1] xyz -hessian[-4] xxxyxzyyyzzz
    --sqr[-3] -*[-10,-1] --sqr[-2] -*[-7,-1] --sqr[-1] -*[-5,-1]
    -*[-8,-7,-5] 2 -*[-8] [-3] -*[-8] [-2] -*[-7] [-3] -*[-7] [-1] -*[-5] [-2] -*[-5] [-1]
    -+[-9--4] -sqr[-3--1] -+[-3--1] -+[-1] 1e-8 -/[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic dog : '_sigma1>=0[%],_sigma2>=0[%]' : Compute difference of gaussian on selected images.
dog : -skip ${1=2%},${2=3%}
  -e "Compute difference of gaussian on image$?, with standard deviations $1 and $2."
  -v- -type float -repeat @#
    --blur[-1] $1 -blur[-2] $2 --[-2,-1] -norm[-1]
  -mv[-1] 0 -done -v+

#@gmic curvature : : Compute isophote curvatures on selected images.
curvature :
  -e "Compute isophote curvatures on image$?."
  -v- -type float -repeat @#
    [-1]x2 -laplacian[-3] -gradient_2derivative[-2] --[-3,-2] -gradient_norm[-1] -+[-1] 1e-8 -/[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic histogram_cumul : '_nb_levels>0,_is_normalized={0|1}' : Compute cumulative histogram of selected images.
histogram_cumul : -skip ${1=256},${2=1}
  -if $2  -e "Compute normalized cumulative histogram of image$?, using $1 levels."
  -else -e "Compute cumulative histogram of image$?, using $1 levels."
  -endif
  -v- -type float -histogram $1 -repeat @#
    -i[-2] [-1],1,1,1,0 -repeat @{-1,w} -+[-2] [-1] -shift[-1] 1 -done -rm[-1]
    -if $2 -/[-1] @{-1,M} -endif
  -mv[-1] 0 -done -v+

#@gmic transfer_histogram : : Transfer histogram of the last selected image to the other ones.
transfer_histogram :
  -e "Transfert histogram of the last selected image to image$?."
  -v- -type float -to_rgb -c 0,255 -equalize[0--2] 256 --histogram_cumul[-1] 256 -/[-1] @{-3,#} -*[-1] 255
  -repeat @#-2
    -s[-3] c -index[-5--3] [-1] -a[-5--3] c
  -mv[-3] 0 -done -rm[-1] -v+

#@gmic complex2polar : : Compute complex to polar transforms of selected images.
complex2polar :
  -e "Compute complex to polar transforms of image$?."
  -v- -type float -repeat {@#/2}
    -r[-1] [-2],3 --atan2[-1] [-2] -sqr[-3,-2] -+[-3,-2] -sqrt[-2]
  -mv[-2,-1] 0 -done -v+

#@gmic polar2complex : : Compute polar to complex transforms of selected images.
polar2complex :
  -e "Compute polar to complex transforms of image$?."
  -v- -type float -repeat {@#/2}
    -r[-1] [-2],3 --sin[-1] -cos[-2] -*[-1] [-3] -*[-3,-2]
  -mv[-2,-1] 0 -done -v+

#@gmic split_freq : 'smoothness>0[%]' : Split selected images into low and high frequency parts.
split_freq : -skip ${1=2%}
  -e "Split image$? into low and high frequency parts, with smoothness $1."
  -v- -type float -repeat @#
    --blur[-1] $1 --[-2] [-1] -reverse[-2,-1]
  -mv[-2,-1] 0 -done -v+

#@gmic compose_freq : : Compose selected low and high frequency parts into new images.
compose_freq :
  -e "Compose low and high frequency part$? into new images."
  -v- -type float -repeat {@#/2}
    -+[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic direction2rgb : : Compute RGB representation of selected 2D direction fields.
direction2rgb :
  -e "Compute RGB representation of 2D direction field$?."
  -v- -type float -repeat @#
    -channels[-1] 0,1 -s[-1] c -complex2polar[-2,-1]
    -*[-1] 128 -/[-1] 3.14159265359 -+[-1] 256 -mod[-1] 256 -map[-1] 1
    -to_rgb[-2] -n[-2] 0,1 -*[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic normalize_sum : : Normalize selected images with a unitary sum.
normalize_sum :
  -e "Normalize image$? with a unitary sum."
  -v- -type float -repeat @#
    (@{-1,+}) -if {@-1>0} -/[-2] @-1 -endif -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic normalize_local : '_amplitude>=0,_radius>0,_n_smooth>=0[%],_a_smooth>=0[%],_cut={0|1},_min=0,_max=255' : Normalize selected images locally.
normalize_local : -skip ${1=3},${2=128},${3=4%},${4=2%},${5=1},${6=0},${7=255}
  -e "Normalize image$? locally, with amplitude $1, radius $2, neighborhood smoothness $3 and average smoothness $4."
  -v- -type float -repeat @#
    --l[-1] -erode {2*$2+1} -s c -min -endl
    --l[-2] -dilate {2*$2+1} -s c -max -endl
    --blur[-3] $4 -blur[-3,-2] $3
    ---[-2] [-3] -+[-1] 0.01 --[-5] [-4] -/[-5,-1]
    -*[-3,-2] {$1+1} -*[-1] -$1 -+[-3] [-1] -+[-2,-1]
    -if $5 -max[-2] $6 -min[-1] $7 -endif
    --[-1] [-2] -*[-3,-1] -+[-2,-1]
    -if $5 -c[-1] $6,$7 -endif
  -mv[-1] 0 -done -v+

#@gmic convolve_fft : : Convolve selected images two-by-two through Fourier transforms.
convolve_fft :
  -e "Convolve image$? two-by-two through Fourier transforms."
  -v- -type float -repeat {@#/2}
    -r[-1] 100%,100%,100%,[-2],1 -r[-1] [-2],0,0,1 -shift[-1] -50%,-50%,-50%,0,2
    -fft[-2] -fft[-1] -shift[-1] -50%,-50%,-50%,0,2
    --*[-4] [-1] --*[-4] [-3] -+[-2,-1]
    -*[-5,-3] -*[-3,-2] --[-3,-2]
    -ifft[-2,-1] -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic deconvolve_fft : : Deconvolve selected images two-by-two through Fourier transforms.
deconvolve_fft :
  -e "Deconvolve image$? two-by-two through Fourier transforms."
  -v- -type float -repeat {@#/2}
    -r[-1] 100%,100%,100%,[-2],1 -r[-1] [-2],0,0,1 -shift[-1] -50%,-50%,-50%,0,2
    -fft[-2] -fft[-1] -shift[-1] -50%,-50%,-50%,0,2
    --sqr[-2] --sqr[-2] -+[-2,-1] -+[-1] 0.0001 -/[-5--2] [-1] -rm[-1]
    --*[-3] [-2] --*[-5] [-2] --[-2,-1]
    -*[-5,-3] -*[-3,-2] -+[-3,-2]
    -ifft[-2,-1] -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic to_tensors : : Convert selected vector fields to corresponding diffusion tensor fields.
to_tensors :
  -e "Convert vector field$? to diffusion tensor field$?."
  -v- -type float -repeat @# -l[-1]
    -s c
    -if {@#==2} --sqr[-1] -*[-2] [-3] -sqr[-3]
    -elif {@#==3} --sqr[-2] --*[-3] [-2] --sqr[-3] -*[-5,-4] [-6] -sqr[-6]
    -else -error "Invalid image : Dimensions @{-1,w},@{-1,h},@{-1,d},@{-1,s} does not represent a field of 2D or 3D vectors."
    -endif
    -a c
  -endl -mv[-1] 0 -done -v+

#@gmic display_fft : : Display Fourier transform of selected images, with centered log-module and argument (eq. to '-dfft').
display_fft :
  -e "Display Fourier transform of image$? with centered log-module and argument."
  -v- -type float -repeat @#
    -fft[-1] -complex2polar[-2,-1] -shift[-2,-1] 50%,50%,50%,0,2 -+[-2] 1 -log[-2] -n[-2,-1] 0,255 -a[-2,-1] x
  -mv[-1] 0 -done -s x,2 -v+

dfft :
  -display_fft

#@gmic display_rgba : : Render selected RGBA images over a checkerboard background (eq. to '-drgba').
display_rgba :
  -e "Render RGBA image$? over a checkerboard background."
  -v- -repeat @#
    -i[-2] (160,128;128,160) -r[-2] 16,16 -r[-2] [-1],[-1],1,3,0,2 -compose_rgba[-2,-1]
  -mv[-1] 0 -done -v+

drgba :
  -display_rgba

#-----------------------------
#
# Geometric filters
#
#-----------------------------

#@gmic resize2dx : 'width>0,_interpolation_type={0,1,2,3,4,5}' : Resize selected images along the X-axis, preserving 2D ratio (eq. to '-r2dx').
resize2dx : -check {"$1>0 && ${2=2}>=0 && $2<=5"}
  -e "Resize 2D image$? to $1 pixels along the X-axis, preserving 2D ratio."
  -v- -type float -repeat @#
    (@{-1,h}) -*[-1] $1 -/[-1] @{-2,w} -c[-1] 1,100%
    -r[-2] $1,@-1,[-2],[-2],$2 -rm[-1]
  -mv[-1] 0 -done -v+

r2dx :
  -resize2dx $*

#@gmic resize3dx : 'width>0,_interpolation_type={0,1,2,3,4,5}' : Resize selected images along the X-axis, preserving 3D ratio (eq. to '-r3dx').
resize3dx : -check {"$1>0 && ${2=2}>=0 && $2<=5"}
  -e "Resize 3D image$? to $1 pixels along the X-axis, preserving 3D ratio."
  -v- -type float -repeat @#
    (@{-1,h},@{-1,d}) -*[-1] $1 -/[-1] @{-2,w} -c[-1] 1,100%
    -r[-2] $1,@-1,[-2],$2 -rm[-1]
  -mv[-1] 0 -done -v+

r3dx :
  -resize3dx $*

#@gmic resize2dy : 'height>0,_interpolation_type={0,1,2,3,4,5}' : Resize selected images along the Y-axis, preserving 2D ratio (eq. to '-r2dy').
resize2dy : -check {"$1>0 && ${2=2}>=0 && $2<=5"}
  -e "Resize 2D image$? to $1 pixels along the Y-axis, preserving 2D ratio."
  -v- -type float -repeat @#
    (@{-1,w}) -*[-1] $1 -/[-1] @{-2,h} -c[-1] 1,100%
    -r[-2] @-1,$1,[-2],[-2],$2 -rm[-1]
  -mv[-1] 0 -done -v+

r2dy :
  -resize2dy $*

#@gmic resize3dy : 'height>0,_interpolation_type={0,1,2,3,4,5}' : Resize selected images along the Y-axis, preserving 3D ratio (eq. to '-r3dy').
resize3dy : -check {"$1>0 && ${2=2}>=0 && $2<=5"}
  -e "Resize 3D image$? to $1 pixels along the Y-axis, preserving 3D ratio."
  -v- -type float -repeat @#
    (@{-1,w},@{-1,h}) -*[-1] $1 -/[-1] @{-2,h} -c[-1] 1,100%
    -r[-2] @{-1,0},$1,@{-1,1},[-2],$2 -rm[-1]
  -mv[-1] 0 -done -v+

r3dy :
  -resize3dy $*

#@gmic resize3dz : 'depth>0,_interpolation_type={0,1,2,3,4,5}' : Resize selected images along the Z-axis, preserving 3D ratio (eq. to '-r3dz').
resize3dz : -check {"$1>0 && ${2=2}>=0 && $2<=5"}
  -e "Resize 3D image$? to $1 pixels along the Z-axis, preserving 3D ratio."
  -v- -type float -repeat @#
    (@{-1,w},@{-1,h}) -*[-1] $1 -/[-1] @{-2,d} -c[-1] 1,100%
    -r[-2] @-1,$1,[-2],$2 -rm[-1]
  -mv[-1] 0 -done -v+

r3dz :
  -resize3dz $*

#@gmic expand_x : 'size_x>=0,_borders={0,1,2}' : Expand selected images along the X-axis.
expand_x : -check {"$1>=0 && ${2=1}>=0 && $2<=2"}
  -e "Expand image$? along the X-axis with size $1 and border conditions $2."
  -v- -type float -repeat @#
    -if {$2==0} $1,100%,100%,100% -i[-3] [-1] -a[-3--1] x
    -elif {$2==1} --columns[-1] 0 --columns[-2] 100% -r[-2,-1] $1 -mv[-2] -3 -a[-3--1] x
    -else (@{-1,w}) -+[-1] $1 -+[-1] $1 -r[-2] @-1,[-2],[-2],[-2],0,2,1 -rm[-1]
    -endif
  -mv[-1] 0 -done -v+

#@gmic expand_y : 'size_y>=0,borders={0,1,2}' : Expand selected images along the Y-axis.
expand_y : -check {"$1>=0 && ${2=1}>=0 && $2<=2"}
  -e "Expand image$? along the Y-axis with size $1 and border conditions $2."
  -v- -type float -repeat @#
    -if {$2==0} 100%,$1,100%,100% -i[-3] [-1] -a[-3--1] y
    -elif {$2==1} --lines[-1] 0 --lines[-2] 100% -r[-2,-1] 100%,$1 -mv[-2] -3 -a[-3--1] y
    -else (@{-1,h}) -+[-1] $1 -+[-1] $1 -r[-2] [-2],@-1,[-2],[-2],0,2,1 -rm[-1]
    -endif
  -mv[-1] 0 -done -v+

#@gmic expand_z : 'size_z>=0,borders={0,1,2}' : Expand selected images along the Z-axis.
expand_z : -check {"$1>=0 && ${2=1}>=0 && $2<=2"}
  -e "Expand image$? along the Z-axis with size $1 and border conditions $2."
  -v- -type float -repeat @#
    -if {$2==0} 100%,100%,$1,100% -i[-3] [-1] -a[-3--1] z
    -elif {$2==1} --slices[-1] 0 --slices[-2] 100% -r[-2,-1] 100%,100%,$1 -mv[-2] -3 -a[-3--1] z
    -else (@{-1,d}) -+[-1] $1 -+[-1] $1 -r[-2] [-2],[-2],@-1,[-2],0,2,1 -rm[-1]
    -endif
  -mv[-1] 0 -done -v+

#@gmic shrink_x : 'size_x>=0' : Shrink selected images along the X-axis.
shrink_x : -check {$1>=0}
  -e "Shrink image$? along the X-axis with size $1."
  -v- -type float -repeat @#
    (@{-1,w}) --[-1] $1 --[-1] 1 -crop[-2] $1,@-1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic shrink_y : 'size_y>=0' : Shrink selected images along the Y-axis.
shrink_y : -check {$1>=0}
  -e "Shrink image$? along the Y-axis with size $1."
  -v- -type float -repeat @#
    (@{-1,h}) --[-1] $1 --[-1] 1 -crop[-2] 0,$1,100%,@-1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic shrink_z : 'size_z>=0' : Shrink selected images along the Z-axis.
shrink_z : -check {$1>=0}
  -e "Shrink image$? along the Z-axis with size $1."
  -v- -type float -repeat @#
    (@{-1,d}) --[-1] $1 --[-1] 1 -crop[-2] 0,0,$1,100%,100%,@-1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic array : '_M>0,_N>0,_expand_type={0,1,2}' : Create MxN array from selected images.
array : -skip ${1=3},${2=$1},${3=0}
  -e "Create $1x$2 array from image$?, with expand type $3."
  -v- -repeat @#
    -array_expand$3 $1,$2 [-1]x$1 -rm[-1] -a[-$1--1] x [-1]x$2 -rm[-1] -a[-$2--1] y
  -mv[-1] 0 -done -v+
array_expand0 :
  (100) ($1,$2) -/[-2] @{-1,M} -rm[-1] -r[-2] @-1%,@-1%,1,100%,2 -rm[-1]
array_expand1 :
  (100) ($1,$2) -/[-2] @{-1,m} -rm[-1] -r[-2] @-1%,@-1%,1,100%,2 -rm[-1]
array_expand2 :
  -skip $*

#@gmic array_fade : '_M>0,_N>0,0<=_fade_start<=100,0<=_fade_end<=100,_expand_type={0,1,2}' : Create MxN array from selected images.
array_fade : -skip ${1=3},${2=$1},${3=60},${4=90},${5=1}
  -e "Create $1x$2 array of ($3%,$4%) faded tiles from image$?, with expand type $5."
  -v- -repeat @#
    --shift[-1] 50%,50%,1,1,2 -mv[-1] -2 -fade_diamond[-2,-1] $3,$4 -array[-1] $1,$2,$5
  -mv[-1] 0 -done -v+

#@gmic array_mirror : '_N>=0,_dir={0,1,2},_expand_type={0|1}' : Create 2^Nx2^N array from selected images.
array_mirror : -skip ${1=2},${2=2},${3=0}
  -e "Create a 2^$1x2^$1 mirrored-array from image$?, with expand type $2."
  -v- -repeat $1
    -if {$3==0} -r 50%,50%,100%,100%,2 -endif
    -repeat @#
      -if {$2==0} --mirror[-1] x -a[-2,-1] x
      -elif {$2==1} --mirror[-1] y -a[-2,-1] y
      -else --mirror[-1] x -a[-2,-1] x --mirror[-1] y -a[-2,-1] y
      -endif
    -mv[-1] 0 -done
  -done -v+

#@gmic array_random : '_Ms>0,_Ns>0,_Md>0,_Nd>0' : Create MdxNd array of tiles from selected MsxNs source arrays.
array_random : -skip ${1=5},${2=$1},${3=$1},${4=$2}
  -e "Create $3x$4 array of tiles from $1x$2 array$?."
  -v- -repeat @#
    -l[-1] -split_tiles $1,$2
    -repeat $3 -repeat $4 [{round(?(0,$1*$2),1,-1)}] -done -done
    -rm[0-{$1*$2-1}] -append_tiles $3,$4
  -endl -mv[-1] 0 -done -v+

#@gmic taquin : '_M>0,_N>0' : Create MxN taquin puzzle from selected images.
taquin : -skip ${1=4},${2=$1}
 -e "Create $1x$2 taquin puzzle from image $?."
 -v- -repeat @# -l[-1]
   -split_tiles $1,$2,1 -repeat {$1*$2} -mv[@{>,-1}] {?(0,@#)} -done -append_tiles $1,$2
 -endl -mv[-1] 0 -done -v+

#@gmic grid : '_M>0,_N>0' : Create MxN image grid from selected images.
grid : -skip ${1=10},${2=$1}
  -e "Create $1x$2 image grid from image$?."
  -v- -repeat @#
    (@{-1,w},@{-1,h}) ($1,$2) -/[-2,-1] -r[-2] @-1,[-2],[-2],2 -rm[-1]
    (@{-1,w},@{-1,h}) ($1,$2) -*[-2,-1] -r[-2] @-1,[-2],[-2],2 -rm[-1]
    $1,$2,1,[-1],1 -shift[-1] 1,1 -r[-1] [-2],0,2 -*[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic frame : '_size_x>=0,_size_y>=0,_R,_G,_B,_A' : Insert RGBA-colored frame in selected images.
frame : -skip ${1=20},${2=$1},${3=255},${4=$3},${5=$4},${6=255}
  -e "Insert $1x$2 frame with RGBA color ($3,$4,$5,$6) in image$?."
  -v- -to_rgba -repeat @#
    ($3^$4^$5^$6) -r[-1] $1,[-2],[-2],[-2],1 -i[-3] [-1] -a[-3--1] x
    ($3^$4^$5^$6) -r[-1] [-2],$2,[-2],[-2],1 -i[-3] [-1] -a[-3--1] y
  -mv[-1] 0 -done -v+

#@gmic frame_fuzzy : '_size_x>=0,_size_y>=0,_fuzzyness>=0,_smoothness>=0,_R,_G,_B,_A' : Draw RGBA-colored fuzzy frame in selected images.
frame_fuzzy : -skip ${1=20},${2=$1},${3=5},${4=1},${5=255},${6=$5},${7=$6},${8=255}
  -e "Draw $1x$2 fuzzy frame on image$?, with fuzzyness $3, smoothness $4 and RGBA color ($5,$6,$7,$8)."
  -v- -to_rgba -repeat @#
    -i[0] ($1;$2) -*[0] 2 ($5^$6^$7^$8) -r[-1] [-2] 100%,100%
    -polygon[-1] 4,0,0,100%,0,100%,@{0,1},0,@{0,1},1,1
    -polygon[-1] 4,0,0,@{0,0},0,@{0,0},100%,0,100%,1,1
    -rm[0] -shift[-1] -$1,-$2,0,0,2 -spread[-1] $3 -blur[-1] $4 -_fade 50,80
  -mv[-1] 0 -done -v+

#@gmic frame_round : '_sharpness>0,_size>=0,_smoothness,_R,_G,_B,_A' : Draw RGBA-colored round frame in selected images.
frame_round : -skip ${1=3},${2=10},${3=0},${4=255},${5=$4},${6=$5},${7=255}
  -e "Draw round frame on image$?, with sharpness $1, size $2, smoothness $3 and RGBA color ($4,$5,$6,$7)."
  -v- -to_rgba -repeat @#
    100%,100%,1,1,"-(abs(x/w-0.5)^$1+abs(y/h-0.5)^$1)^(1/$1)" -t[-1] $2%
    -blur[-1] $3 -r[-1] [-2] -*[-2] [-1] -channels[-1] 0 -*[-1] -1 -+[-1] 1
    --*[-1] $5 --*[-2] $6 --*[-3] $7 -*[-4] $4 -a[-4--1] c -+[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic polaroid : '_size1>=0,_size2>=0' : Create polaroid effect in selected images.
polaroid : -skip ${1=10},${2=20}
  -e "Create polaroid effect in image$?, with borders sizes $1 and $2."
  -v- -- 255 -r {100+$1}%,{100+$1}%,1,100%,0,0,1 -r 100%,{100+$2}%,1,100%,0,0,0 -+ 255 -v+

#@gmic drop_shadow : '_offset_x,_offset_y,_smoothness,_expansion' : Drop shadow behind selected images.
drop_shadow : -skip ${1=-10},${2=$1},${3=1},${4=20}
  -e "Drop shadow behind image$?, with offsets ($1,$2), smoothness $3 and expansion $4."
  -v- -to_rgba -repeat @#
    -r[-1] {100+$4}%,{100+$4}%,1,100%,0,0,1 -s[-1] c --blur[-1] $3% -shift[-1] $1%,$2% -or[-2,-1] -a[-4--1] c
  -mv[-1] 0 -done -v+

#@gmic split_tiles : 'M!=0,_N!=0,_is_homogeneous={0|1}' : Split selected images as a MxN array of tiles.
split_tiles : -skip $1,${2=$1},${3=0}
  -if $3 -e "Split image$? as a array of homogeneous tiles, with (M,N) = ($1,$2)."
  -else -e "Split image$? as a array of tiles, with (M,N) = ($1,$2)."
  -endif
  -v- -repeat @#
    -l[-1] -s y,$2 -s x,$1 -if $3 -r [0],[0],100%,100%,0 -endif -endl
  -mv[{-$1*$2}--1] 0 -done -v+

#@gmic append_tiles : 'M>0,_N>0' : Append MxN selected tiles as a new image.
append_tiles : -skip $1,${2=$1}
  -e "Append $1x$2 tile$? as new image(s)."
  -v- -repeat {@#/($1*$2)} -l[{-$1*$2}--1]
    -repeat $2 -a[-$1--1] x -mv[-1] 0 -done -a y
  -endl -mv[-1] 0 -done -v+

#@gmic rotate_tiles : '_angle,_M>0,N>0' : Apply MxN tiled-rotation effect on selected images.
rotate_tiles : -skip ${1=5},${2=8},${3=$2}
  -e "Apply $2x$3 tiled-rotation effect on image$?, with angle $1."
  -v- -split_tiles $2,$3,1 -rotate $1 -append_tiles $2,$3 -v+

#@gmic shift_tiles : '_M>0,_N>0,_amplitude' : Apply MxN tiled-shift effect on selected images.
shift_tiles : -skip ${1=8},${2=8},${3=20}
  -e "Apply $1x$2 tiled-shift effect on image$?, with amplitude $3."
  -v- -type float -repeat @#
    $1,$2,1,2 -noise[-1] $3 -r[-1] [-2],[-2],1,2 -warp[-2] [-1],1,1,0 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic rgb2bayer : '_start_pattern=0,_color=0' : Transform selected color images to RGB-Bayer sampled images.
rgb2bayer : -skip ${1=0},${2=0}
  -if $2 -e "Transform image$? to a RGB-Bayer color grid, starting from pattern '$1'."
  -else -e "Transform image$? to a RGB-Bayer monochrome grid, starting from pattern '$1'."
  -endif
  -v- -to_rgb -repeat @#
    -rgb2bayer_$1 -r[-1] [-2],0,2 -*[-2,-1]
    -if $2 -else -s[-1] c -+[-3--1] -endif
  -mv[-1] 0 -done -v+

rgb2bayer_0 : (1,0;0,0^0,1;1,0^0,0;0,1)
rgb2bayer_1 : (0,0;0,1^0,1;1,0^1,0;0,0)
rgb2bayer_2 : (0,0;1,0^1,0;0,1^0,1;0,0)
rgb2bayer_3 : (0,1;0,0^1,0;0,1^0,0;1,0)

#@gmic warp_perspective : '_x-angle,_y-angle,_zoom>0,_x-center,_y-center,_borders={0,1,2}' : Warp selected images with perspective deformation.
warp_perspective : -skip ${1=1.5},${2=0},${3=1},${4=50},${5=50},${6=2}
  -e "Apply perspective warp on image$?, with angles ($1,$2), zoom $3 and offsets ($4,$5)."
  -v- -type float -repeat @#
    (0,100) --[-1] $4 -/[-1] 100 (0;100) --[-1] $5 -/[-1] 100 -r[-2,-1] [-3],[-3],[-3],1,3
    --*[-2] $2 --*[-2] $1 -+[-2,-1] -+[-1] $3 -/[-3] [-1] -/[-2,-1]
    -*[-2] 100 -+[-2] $4 -/[-2] 100 -*[-2] @{-3,w}
    -*[-1] 100 -+[-1] $5 -/[-1] 100 -*[-1] @{-3,h}
    -a[-2,-1] c -warp[-2] [-1],0,1,$6 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic array_pattern : '_M>0,_N>0,_density>=0,_angle>=0,_zoom>=0,_opacity,_expand_type={0,1,2}' : Create random MxN array from selected images.
array_pattern : -skip ${1=10},${2=10},${3=80},${4=180},${5=30},${6=1},${7=0}
  -e "Create $1x$2 pattern array from image$?, with density $3, angle $4, zoom $5, opacity $6 and expand type $7."
  -v- -repeat @#
    -array_expand$7 $1,$2 -set[-1] 0,0,0,0,3
    --crop[-1] 0,0,0,0,0,0,0,100% ($1,$2) (@{-3,w},@{-3,h}) -*[-2,-1] -r[-2] @-1,1,100% -rm[-1]
    $1,$2,1,1,-1 -noise[-1] $3,2 -t[-1] 0 -unroll[-1] y
    -repeat $1 -repeat $2
      -if @{-1,0}
        ({?(-$5,$5)}) -+[-1] 100 --r[-4] @-1%,@-1%,1,100%,3 -rm[-2] --f[-1] 1
        (@{>,-2--1}) (@{-6,w},@{-6,h}) -*[-2,-1]
        ({?(-$4,$4)}) -rotate[-4] @-1,1,2 -rotate[-3] @-1,0,0 -rm[-1]
        -image[-5] [-3],@{-1},0,$6,[-2] -rm[-3--1]
      -endif
    -shift[-1] 0,-1 -done -done -rm[-3,-1]
  -mv[-1] 0 -done -v+

#------------------------------------
#
# Deformation and smoothing filters
#
#------------------------------------

#@gmic spread : '_dx>=0,_dy>=0,_dz>=0' : Spread pixel values of selected images randomly along x,y and z.
spread : -skip ${1=3},${2=$1},${3=0}
  -e "Spread pixel of image$? randomly, with amplitudes ($1,$2,$3)."
  -v- -type float -repeat @#
    100%,100%,100%,1 [-1]x2 -noise[-3] $1,0 -noise[-2] $2,0 -noise[-1] $3,0 -a[-3--1] c -warp[-2] [-1],1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic euclidean2polar : '_cx,_cx,_n>0,_borders={0,1,2}' : Apply euclidean to polar transform on selected images.
euclidean2polar : -skip ${1=0.5},${2=0.5},${3=1},${4=1}
  -e "Apply euclidean to polar transform on image$?."
  -v- -type float -repeat @#
    (@{-1,w},@{-1,h}) ($1,$2) -*[-2,-1] ({sqrt(max(@{-1,0},@{-2,w}-@{-1,0})^2+max(@{-1,1},@{-2,h}-@{-1,1})^2)})
    -a[-2,-1] x
    [-2],[-2],1,1,"@{-1,2}*(x/w)^$3*cos(y*2*pi/h)" -+[-1] @{-2,0}
    [-1],[-1],1,1,"@{-2,2}*(x/w)^$3*sin(y*2*pi/h)" -+[-1] @{-3,1}
    -rm[-3] -a[-2,-1] c -warp[-2] [-1],0,1,$4 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic polar2euclidean : '_cx,_cy,_n>0,_borders={0,1,2}' : Apply polar to euclidean transform on selected images.
polar2euclidean : -skip ${1=0.5},${2=0.5},${3=1},${4=1}
  -e "Apply polar to euclidean transform on image$?."
  -v- -type float -repeat @#
    (@{-1,w},@{-1,h}) ($1,$2) -*[-2,-1] ({sqrt(max(@{-1,0},@{-2,w}-@{-1,0})^2+max(@{-1,1},@{-2,h}-@{-1,1})^2)})
    -a[-2,-1] x
    [-2],[-2],1,1,"w*(sqrt((x-@{-1,0})^2+(y-@{-1,1})^2)/@{-1,2})^(1/$3)"
    [-1],[-1],1,1,"(atan2(y-@{-2,1},x-@{-2,0})*h/(2*pi)+h)%h"
    -rm[-3] -a[-2,-1] c -warp[-2] [-1],0,1,$4 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic water : '_amplitude>=0,_smoothness>=0' : Apply water deformation on selected images.
water : -skip ${1=30},${2=1.5}
  -e "Apply water deformation on image$?, with amplitude $1 and smoothness $2."
  -v- -type float -repeat @#
    25%,25%,25%,1 -noise[-1] $1 -gradient[-1] xyz -+[-1,-2,-3] -blur[-1] $2 -*[-1] 2 -r[-1] [-2],[-2],1,2,3 -warp[-2] [-1],1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic wave : '_amplitude>=0,_frequency>=0,_center_x,_center_y' : Apply wave deformation on selected images.
wave : -skip ${1=4},${2=0.4},${3=50},${4=50}
  -e "Apply wave deformation on image$?, with amplitude $1, frequency $2 and center at ($3%,$4%)."
  -v- -type float -repeat @#
    100%,100% -=[-1] 1,$3%,$4% -distance[-1] 1
    -*[-1] $2 --sin[-1] -cos[-2] -a[-2,-1] c -*[-1] $1
    -warp[-2] [-1],1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic twirl : '_amplitude,_cx,_cy,_borders={0,1,2}' : Apply twirl deformation on selected images.
twirl : -skip ${1=1},${2=0.5},${3=0.5},${4=1}
  -e "Apply twirl deformation on image$?, with amplitude $1 and center at ($2%,$3%)."
  -v- -type float -repeat @#
    -euclidean2polar[-1] $2,$3,1,$4 100%,100%,1,1,$1*x -channels[-1] -1,0
    -warp[-2] [-1],1,1,2 -rm[-1] -polar2euclidean[-1] $2,$3,1,1
  -mv[-1] 0 -done -v+

#@gmic flower : '_amplitude,_frequency,_offset_r[%],_angle,_cx,_cy,_borders={0,1,2}' : Apply flower deformation on selected images.
flower : -skip ${1=30},${2=6},${3=0},${4=0},${5=0.5},${6=0.5},${7=2}
  -e "Apply flower deformation on image$?, with amplitude $1, frequency $2, offset $3, angle $4 and center ($1,$2)."
  -v- -type float -repeat @#
    -euclidean2polar[-1] $5,$6,1,$7 -shift[-1] $3,0,0,0,2
    100%,100%,1,1,"y" -/[-1] @{-1,h} -*[-1] $2 ({$4/360}) -+[-2] @-1 -rm[-1] -*[-1] 6.2831853 -sin[-1]
    -*[-1] $1 -*[-1] @{-1,w} -/[-1] 100
    -channels[-1] 0,1 -warp[-2] [-1],1,1,$7 -rm[-1]
    -polar2euclidean[-1] $5,$6,1,1
  -mv[-1] 0 -done -v+

#@gmic blur_x : '_amplitude,_borders={0|1}' : Blur selected images along the X-axis.
blur_x : -skip ${1=10},${2=1}
  -_blur_n $1,$2,X,y,z

#@gmic blur_y : '_amplitude,_borders={0|1}' : Blur selected images along the Y-axis.
blur_y : -skip ${1=10},${2=1}
  -_blur_n $1,$2,Y,x,z

#@gmic blur_z : '_amplitude,_borders={0|1}' : Blur selected images along the Z-axis.
blur_z : -skip ${1=10},${2=1}
  -_blur_n $1,$2,Z,x,y

_blur_n :
  -e "Blur image$? along the $3-axis, with amplitude $1 and border conditions $2."
  -v- -repeat @#
    -l[-1] -s $5 -repeat @#
      -l[-1] -s $4 -blur $1,$2 -a $4 -endl
    -mv[-1] 0 -done -a $5 -endl
  -mv[-1] 0 -done -v+

#@gmic blur_angular : '_amplitude,_cx,_cy' : Apply angular blur on selected images.
blur_angular : -skip ${1=10},${2=0.5},${3=0.5}
  -e "Apply angular blur on image$?, with amplitude $1 and center ($2,$3)."
  -v- -type float -euclidean2polar $2,$3,1.3,1 -expand_y 16,2 -blur_y $1 -shrink_y 16 -polar2euclidean $2,$3,1.3,1 -v+

#@gmic blur_radial : '_amplitude,_cx,_cy' : Apply radial blur on selected images.
blur_radial : -skip ${1=0.1},${2=0.5},${3=0.5}
  -e "Apply radial blur on image$?, with amplitude $1 and center ($2,$3)."
  -v- -type float -euclidean2polar $2,$3,5,1 -blur_x $1 -polar2euclidean $2,$3,5,1 -v+

#@gmic blur_linear : '_amplitude1,_amplitude2,_angle=0,_borders={0|1}' : Apply linear blur on selected images, with specified angle and amplitudes.
blur_linear : -skip ${1=0.2},${2=0.02},${3=0},${4=1}
  -e "Apply linear blur on image$?, with angle $3 and amplitudes ($1,$2)."
  -v- -type float -repeat @#
    -if {$4==1} -expand_x[-1] 16 -expand_y[-1] 16 -else -frame 16,16,0 -endif
    ($3,$3) -+[-1] 90 -=[-1] $3,1 -/[-1] 180 -*[-1] 3.14159265359 -sin[-1]
    (-1,1) (-1;1) -r[-2,-1] [-4],[-4],[-4],1,3
    --*[-1] @{-3,0} --*[-3] @{-4,1} --[-2,-1] -/[-1] $2 -sqr[-1]
    -*[-3] @{-4,0} -*[-2] @{-4,1} -+[-3,-2] -/[-2] $1 -sqr[-2]
    -+[-2,-1] -*[-1] -1 -exp[-1] -normalize_sum[-1] -rm[-2]
    -convolve_fft[-2,-1] -shrink_x[-1] 16 -shrink_y[-1] 16
  -mv[-1] 0 -done -v+

#@gmic pde_flow : '_nb_iter>=0,_dt,_velocity_command,_sequence_flag={0|1}' : Apply iterations of a generic PDE flow on selected images.
pde_flow : -skip ${1=10},${2=30},${3=laplacian},${4=0}
  -e "Apply $1 iterations of the velocity flow '$3' on image$?, with time step $2."
  -v- -type float -repeat @# -l[-1] -repeat $1
    --$3[-1] (@{-1,m},@{-1,M}) -abs[-1] -+[-1] 0.01 -/[-2] @{-1,M} -rm[-1] -*[-1] $2
    -if $4 -+[-1] [-2] -else -+[-2,-1] -endif
  -done -if $4 -rm[0] -endif -a x -endl
  -mv[-1] 0 -done -if $4 -s x,$1 -endif -v+

#@gmic heat_flow : '_nb_iter>=0,_dt,_sequence_flag={0|1}' : Apply iterations of the heat flow on selected images.
heat_flow : -skip ${1=10},${2=30},${3=0}
  -e "Apply $1 iterations of the heat flow on image$?, with time step $2."
  -v- -pde_flow $1,$2,laplacian,$3 -v+

#@gmic meancurvature_flow : '_nb_iter>=0,_dt,_sequence_flag={0|1}' : Apply iterations of the mean curvature flow on selected images.
meancurvature_flow : -skip ${1=5},${2=30},${3=0}
  -e "Apply $1 iterations of the mean curvature flow on image$?, with time step $2."
  -v- -pde_flow $1,$2,meancurvature_flow_velocity,$3 -v+
meancurvature_flow_velocity :
  --gradient_2derivative[-1] -laplacian[-2] --[-2,-1]

#@gmic tv_flow : '_nb_iter>=0,_dt,_sequence_flag={0|1}' : Apply iterations of the total variation flow on selected images.
tv_flow : -skip ${1=5},${2=30},${3=0}
  -e "Apply $1 iterations of the total variation flow on image$?, with time step $2."
  -v- -pde_flow $1,$2,tv_flow_velocity,$3 -v+

tv_flow_velocity :
  --gradient[-1] xyz -sqr[-3--1] -+[-3--1] -sqrt[-1] -+[-1] 0.1 -meancurvature_flow_velocity[-2] -/[-2,-1]

#@gmic inpaint_flow : '_nb_iter1>=0,_nb_iter2>=0,_dt>=0,_alpha,_sigma' : Apply iteration of the inpainting flow on selected images.
inpaint_flow : -skip ${1=4},${2=15},${3=15},${4=1},${5=3}
  -e "Apply $1 iteration of the inpainting flow on image$?."
  -v- -norm[0] -quantize[0] 2 -n[0] 0,1 -repeat @# -if @{>,-1} -l[0,@{>,-1}]
  -r[0] [1] -inpaint[1] [0]
  -repeat $1
     --edgetensors[1] 0,1,$4,$5,0 -*[2] [0] -smooth[1] [2],$2,$3,0 -rm[2]
  -done
  -endl -endif -done -v+

#@gmic noise_hurl : '_amplitude>=0' : Add hurl noise to selected images.
noise_hurl : -skip ${1=10}
  -e "Add hurl noise to image$?, with amplitude $1%."
  -v- -type float -repeat @#
    --f[-1] 0 -noise[-1] 10 -n[-1] @{-2,m,M} 100%,100%,1,1,-2
    -noise[-1] $1,2 -t[-1] 0 -r[-1] [-2]
    -*[-2] [-1] -*[-1] -1 -+[-1] 1 -*[-3,-1] -+[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic pixelize : '_scale_x>0,_scale_y>0,_scale_z>0' : Pixelize selected images with specified scales.
pixelize : -skip ${1=20},${2=$1},${3=$1}
  -e "Pixelize image$? with scales ($1%,$2%,$3%)."
  -v- -repeat @#
    (@{-1,w},@{-1,h},@{-1,d}) -r[-2] $1%,$2%,$3%,[-2],2 -r[-2] @-1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic deform : '_amplitude>=0' : Apply random smooth deformation on selected images.
deform : -skip ${1=10}
  -e "Apply random smooth deformation on image$?, with amplitude $1."
  -v- -type float -repeat @#
    2%,2%,1,2 -noise[-1] $1 -r[-1] [-2],[-2],1,2,5 -warp[-2] [-1],1,1,1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic puzzle : '_scale>=0' : Apply puzzle effect on selected images.
puzzle : -skip ${1=5}
  -e "Apply puzzle effect on image$?, with scale $1%."
  -v- -type float -repeat @#
    [-1] -r[-1] $1%,$1%,100%,100%,2 -noise[-1] 0.1 -r[-1] [-2] -rm[-2]
    [-1]x2 -shift[-1] -1,-1 --[-2,-1] -norm[-1] -t[-1] 0.01 -*[-1] -1
    -+[-1] 1 -r[-1] [-2] -*[-1,-2] 10%,10%,10%,2 -noise[-1] 5,1
    -r[-1] [-2],[-2],1,2,5 -warp[-2] [-1],1,1,1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic fish_eye : '_x,_y,0<=_radius<=100,_amplitude>=0' : Apply fish-eye deformation on selected images.
fish_eye : -skip ${1=50},${2=50},${3=50},${4=1.2}
  -if {$4==0} -return -endif
  -e "Apply Fish-eye effect on image$?, centered at ($1%,$2%) with radius $3% and amplitude $4."
  -v- -type float -repeat @#
    100%,100%,1,1 -=[-1] 1,$1%,$2% -distance[-1] 1 -cut[-1] 0,$3% -*[-1] -1 -n[-1] 0,1 -pow[-1] {1/$4}
    -i[-2] ({-$1/100},{1-$1/100};{-$1/100},{1-$1/100}^{-$2/100},{-$2/100};{1-$2/100},{1-$2/100}) -r[-2] [-1],[-1],1,2,3
    -n[-1] 0,{max(@{-1,w},@{-1,h})} -*[-2,-1]
    -warp[-2] [-1],1,1,1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic transform_polar : "expr_radius",_"expr_angle",_x_center,_y_center,_borders={0|1} : Apply user-defined transform on polar representation of selected images.
transform_polar : -skip ${1=r},${2=a},${3=50},${4=50},${5=1}
  -e "Apply custom polar transform with 'new_r="$1"', 'new_a="$2"', centered at ($3%,$4%)."
  -v- -type float
  -repeat @#
  -p {"sqrt((max($3,100-$3)*@{-1,w}/100)^2 + (max($4,100-$4)*@{-1,h}/100)^2)"}
  -p {"$3*@{-1,w}/100"}
  -p {"$4*@{-1,h}/100"}
  -f "R = @{*,-3};
      r = sqrt((x-@{*,-2})^2 + (y-@{*,-1})^2);
      a = atan2(y-@{*,-1},x-@{*,-2});""
      nr = "$1";
      na = "$2";
      i(@{*,-2} + nr*cos(na), @{*,-1} + nr*sin(na), z, c, $5)"
  -pp[-3--1]
  -mv[-1] 0 -done -v+

#-----------------------------
#
# Artistic filters
#
#-----------------------------

#@gmic shade_stripes : '_frequency>=0,_direction={0|1},_darkness>=0,_lightness>=0' : Add shade stripes to selected images.
shade_stripes : -skip ${1=5},${2=1},${3=0.8},${4=2}
  -v- -type float -repeat @#
    -n[-1] 0,255
    -if $2 -v+ -e "Add vertical shaded stripes to image$?, with frequency $1, darkness $3 and lightness $4." -v- 100%
    -else -v+ -e "Add horizontal shaded stripes to image$?, with frequency $1, darkness $3 and lightness $4." -v- 1,100%
    -endif
    -noise[-1] $1,2 -distance[-1] 1
    -r[-1] [-2] -n[-1] $3,$4 -*[-1,-2] -c[-1] 0,255
  -mv[-1] 0 -done -v+

#@gmic stripes_y : '_frequency>=0' : Add vertical stripes to selected images.
stripes_y : -skip ${1=10}
  -e "Add vertical stripes to image$?, with frequency $1."
  -v- -type float -repeat @#
    -n[-1] 0,255 100% -noise[-1] $1,2 -*[-1] 255 -r[-1] [-2]
    -*[-1] 0.15 -+[-1,-2] -c[-1] 0,255
  -mv[-1] 0 -done -v+

#@gmic tetris : '_scale>0' : Apply tetris effect on selected images.
tetris : -skip ${1=10}
  -e "Apply tetris effect on image$?, with scale $1."
  -v- -type float -repeat @#
    --r[-1] $1%,$1%,$1%,3,2 -n[-1] 0,255 -quantize[-1] 10
    -r[-1] [-2] -rm[-2] -blur[-1] 2 -sharpen[-1] 300,1
  -mv[-1] 0 -done -v+

#@gmic damp_patch : '_opacity>=0' : Add damp patches to selected images.
damp_patch : -skip ${1=0.7}
  -e "Apply damp patches to image$?, with opacity $1."
  -v- -type float -repeat @#
    100%,100%,1,1 -shift[-1] -2,-2 -shift[-1] 1,1
    -plasma[-1] 3,0.3 -abs[-1] -blur[-1] 1 -c[-1] 3%,15% -r[-1] [-2]
    -n[-1] $1,1 -*[-1,-2]
  -mv[-1] 0 -done -v+

#@gmic light_patch : '_density>0,_darkness>=0,_lightness>=0' : Add light patches to selected images.
light_patch : -skip ${1=10},${2=0.9},${3=1.7}
  -e "Apply light patches to image$?, with density $1, darkness $2 and lightness $3."
  -v- -type float -repeat @#
    -n[-1] 0,255 $1,$1 -noise[-1] 40 -r[-1] [-2],5 -c[-1] 0,255
    -n[-1] $2,$3 -*[-2,-1] -c[-1] 0,255
  -mv[-1] 0 -done -v+

#@gmic kaleidoscope : '_cx,_cy,_radius,_angle,_borders={0,1,2}' : Create kaleidoscope effect from selected images.
kaleidoscope : -skip ${1=0.5},${2=0.5},${3=100},${4=30},${5=1}
  -e "Create kaleidoscope effect from image$?, with center ($1,$2) radius $3, angle $4."
  -v- -euclidean2polar $1,$2,1,$5 -repeat @#
    --columns[-1] 0,$3% -lines[-1] 0,$4% -r[-1] [-2],0,2 -rm[-2]
  -mv[-1] 0 -done -polar2euclidean $1,$2,1,$5 -v+

#@gmic mosaic : '_density>=0,_amplitude,_relief={0|1}' : Add random mosaic pattern to selected images.
mosaic : -skip ${1=0.2},${2=40},${3=0}
  -e "Add random mosaic pattern to image$?, with density $1."
  -v- -type float -repeat @#
    (@{-1,m},@{-1,M}) [-2],[-2],1,1 -noise[-1] $1,2 -distance[-1] 1 -sharpen[-1] 10000
    -if $3 -gradient[-1] xy -+[-2,-1] -n[-1] -1,1 -else -n[-1] 0,1 -endif
    -*[-1] $2 -+[-3,-1] -c[-2] @-1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic sponge : '_size>0' : Apply sponge effect on selected images.
sponge : -skip ${1=13}
  -e "Apply sponge filter on image$?, with brush size $1."
  -v- -repeat @#
    100%,100%,1,1 -noise[-1] 20,2 -r[-1] [-2] -n[-1] 0,1 -*[-1,-2]
    -_circle $1 -dilate[-2] [-1] -rm[-1]
  -mv[-1] 0 -done -v+
_circle :
  -i 1 -+[-1] 1 -r[-1] $1,$1,1,1,0,0,1 -distance[-1] 1 -n[-1] 0,1 -sqrt[-1] -c[-1] 0.85,0.86 -*[-1] -1 -n[-1] 0,1

#@gmic hearts : '_density>=0' : Apply heart effect on selected images.
hearts : -skip ${1=10}
  -e "Apply heart filter on image$?, with density $1."
  -v- -repeat @#
    100%,100%,1 -noise[-1] $1,2 -r[-1] [-2] -n[-1] 0,1 -*[-1,-2] -_heart9x7
    -mirror[-1] y -dilate[-2] [-1] -rm[-1]
  -mv[-1] 0 -done -v+

_heart9x7 :
  (0,1,1,0,0,0,1,1,0;1,1,1,1,0,1,1,1,1;1,1,1,1,1,1,1,1,1;0,1,1,1,1,1,1,1,0;0,0,1,1,1,1,1,0,0;0,0,0,1,1,1,0,0,0;0,0,0,0,1,0,0,0,0)

#@gmic color_ellipses : '_count>0,_radius>=0,_opacity>=0' : Add random color ellipses to selected images.
color_ellipses : -skip ${1=1400},${2=10},${3=0.1}
  -e "Add $1 random color ellipses to image$?, with maximum radius $2 and opacity $1."
  -v- -repeat @#
    -repeat $1 -ellipse[-1] {?(0,100)}%,{?(0,100)}%,{?(0,$2)}%,{?(0,$2)}%,{?(0,360)},$3,{?(60,255)},{?(60,255)},{?(60,255)} -done
  -mv[-1] 0 -done -v+

#@gmic whirls : '_texture>=0,_smoothness>=0,_darkness>=0,_lightness>=0' : Add random whirl texture to selected images.
whirls : -skip ${1=3},${2=6},${3=0.5},${4=1.8}
  -e "Add random whirl texture to image$?, with texture $1, smoothness $2, darkness $3 and lightness $4."
  -v- -type float -repeat @#
    100%,100% -noise[-1] 0.3,2 -repeat $1 -blur[-1] $2 -gradient_norm[-1] -done
    -n[-1] $3,$4 -r[-1] [-2] -*[-2,-1] -c[-1] 0,255
  -mv[-1] 0 -done -v+

#@gmic edges : '_threshold>=0' : Estimate contours of selected images.
edges : -skip ${1=30}
  -e "Estimate image contours of image$?, with threshold $1."
  -v- -type float -repeat @#
    -gradient_norm[-1] -blur[-1] 0.5 -t[-1] $1% -distance[-1] 0 -equalize[-1] 256
    -negative[-1] -c[-1] 30%,70% -n[-1] 0,1
  -mv[-1] 0 -done -v+

#@gmic isophotes : '_nb_levels>0' : Render isophotes of selected images on a transparent background.
isophotes : -skip ${1=64}
  -e "Render isophote maps from images$?, with $1 levels."
  -v- -to_rgba -repeat @# -l[-1]
    --luminance -repeat $1 --isoline3d[1] {@{>,-1}*255/($1-1)} -done -rm[1] -+3d[1--1] -col3d[-1] 1,1,1
    [0],[0] -object3d[-1] [-2],0,0 -rm[-2] -*[-2,-1]
  -endl -mv[-1] 0 -done -v+

#@gmic topographic_map : '_nb_levels>0,_smoothness' : Render selected images as topographic maps.
topographic_map : -skip ${1=16},${2=2}
  -e "Render topographic maps from image$?, with $1 levels and smoothness $2."
  -v- -type float -to_rgb -repeat @#
    --blur[-1] $2 -isophotes[-1] $1 -threshold[-1] 0.1 -to_rgb[-1] --norm[-1]
    -line[-2,-1] 100%,0,100%,100%,1,1 -line[-2,-1] 0,100%,100%,100%,1,1
    -line[-2,-1] 0,0,100%,0,1,1 -line[-2,-1] 0,0,0,100%,1,1
    -_topographic_map0[-3--1]
    -_topographic_map[-3--1]
    -rm[-3,-1]
  -mv[-1] 0 -done -v+

_topographic_map0 :
  -repeat 4000
    -p {?(@{-1,w})},{?(@{-1,h})}
    -if {@{-1,(@{*,-1})}==0}
      -flood[-2] @{*,-1},0,0,1,@{-3,(@{*,-1},0,0)},@{-3,(@{*,-1},0,1)},@{-3,(@{*,-1},0,2)}
      -flood[-1] @{*,-1},0,0,1,1
    -endif
    -pp[-1]
  -done

_topographic_map :
  -do
    (@{-1,c}) -p @{-1,0},@{-1,1} -rm[-1]
    -if {@{-1,(@{*,-1})}==0}
      -flood[-2] @{*,-1},0,0,1,@{-3,(@{*,-1},0,0)},@{-3,(@{*,-1},0,1)},@{-3,(@{*,-1},0,2)}
      -flood[-1] @{*,-1},0,0,1,1
      -pp[-1]
    -else -pp[-1] -return
    -endif
  -while 1

#@gmic cartoon : '_smoothness,_sharpening,_threshold>=0,_thickness>=0,_color>=0,quantization>0' : Apply cartoon effect on selected images.
cartoon : -skip ${1=0.5},${2=200},${3=40},${4=0.1},${5=1.5},${6=4}
  -e "Apply cartoon effect on image$?, with smoothness $1, sharpening $2, threshold $3, thickness $4, color $5 and quantization $6."
  -v- -to_rgb -blur $1% -sharpen $2,1 -c 0,255 -n 0,255 -type float -repeat @#
    --edges[-1] $3 -blur[-1] $4% -t[-1] 0.9
    -rgb2lab[-2] -s[-2] c -*[-3,-2] $5 -a[-4--2] c -lab2rgb[-2] -quantize[-2] $6 -n[-2] 0,255
    -*[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic drawing : '_amplitude>=0' : Apply drawing effect on selected images.
drawing : -skip ${1=200}
  -e "Apply drawing effect on image$? with amplitude $1."
  -v- -type float -repeat @#
    -smooth[-1] $1,0.2,1,3,3 -blur[-1] 2 -sharpen[-1] 1000 [-1]
    -r[-2] 20,20,1,3,2 -equalize[-2] 256 -index[-1] [-2],1,1 -rm[-2]
  -mv[-1] 0 -done -v+

#@gmic draw_whirl : '_amplitude>=0' : Apply whirl drawing effect on selected images.
draw_whirl : -skip ${1=100}
  -e "Apply whirl drawing effect on image$? with amplitude $1."
  -v- -type float -repeat @#
    100%,100% -noise[-1] 70,2 -*[-1] 255 -r[-1] [-2] -and[-1,-2] -smooth[-1] $1,0,1,2,2
    -sqrt[-1] -n[-1] 0,255 -equalize[-1] 256
  -mv[-1] 0 -done -v+

#@gmic paper_texture : : Add paper texture to selected images.
paper_texture :
  -e "Add paper texture to image$?."
  -v- -type float -repeat @#
    [-1] 30%,30% -noise[-1] 1,2 -r[-1] [-2],[-2],[-2],1,0 -ifft[-1]
    -rm[-1] -shift[-1] 50%,50%,50%,0,2 -sharpen[-1] 1 -n[-1] 1,1.2 -r[-1] [-2]
    -*[-2,-1] -c[-1] [-2],[-2] -rm[-2]
  -mv[-1] 0 -done -v+

#@gmic stencilbw : '_edges>=0,_smoothness>=0' : Apply B&W stencil effect on selected images.
stencilbw : -skip ${1=30},${2=10}
  -e "Apply B&W stencil effect on image$?, with edges $1 and smoothness $2."
  -v- -type float -repeat @#
    -r[-1] 100%,100%,1,100% --edges[-1] $1 -quantize[-2] 3 -blur[-2] $2
    -sharpen[-2] 1000000 -norm[-2] -n[-2] 0,1 -*[-1,-2] -n[-1] 0,255
  -mv[-1] 0 -done -v+

#@gmic pencilbw : '_size>=0,_amplitude>=0' : Apply B&W pencil effect on selected images.
pencilbw : -skip ${1=0.3},${2=60}
  -e "Apply B&W pencil effect on image$?, with size $1 and amplitude $2."
  -v- -type float -repeat @#
    -norm[-1] -blur[-1] $1 -sharpen[-1] 4000 -smooth[-1] $2,0,1 -equalize[-1] 256 -sqrt[-1] -n[-1] 0,255 -to_rgb[-1]
  -mv[-1] 0 -done -v+

#@gmic ditheredbw : : Create dithered B&W version of selected images.
ditheredbw :
  -e "Create dithered B&W version of image$?."
  -v- -type float -repeat @#
    -n[-1] 0,255 -r[-1] 100%,100%,100%,3 2,1,1,3,0,255 -index[-2] [-1],1,1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic dotsbw : : Apply B&W dots effect on selected images.
dotsbw :
  -e "Apply B&W dots effect on image$?."
  -v- -type float -repeat @#
    -norm[-1] --r[-1] 10%,10%,1,1,2 [-1]x4 -t[-5] 10%
    -t[-4] 30% -t[-3] 50% -t[-2] 70% -t[-1] 90%
    -r[-5--1] [-6],4 -shift[-5--1] 5,5 -rm[-6] -_circle 3 -dilate[-6] [-1]
    -rm[-1] -_circle 5 -dilate[-5] [-1] -rm[-1] -_circle 7 -dilate[-4] [-1]
    -rm[-1] -_circle 9 -dilate[-3] [-1] -rm[-1] -_circle 11 -dilate[-2] [-1]
    -rm[-1] -or[-5--1] -n[-1] 0,255 -r[-1] 100%,100%,1,3
  -mv[-1] 0 -done -v+

#@gmic warhol : '_M>0,_N>0,_smoothness>=0,_color>=0' : Create MxN Andy Warhol-like artwork from selected images.
warhol : -skip ${1=3},${2=$1},${3=2},${4=20}
  -e "Create $1x$2 Andy Warhol-like artwork from image$?."
  -v- -type float -repeat @#
    -norm[-1] -blur[-1] $3 -array_expand0 $1,$2 -quantize[-1] 6 -n[-1] 0,5 -round[-1] 1
    -l[-1] -repeat $1 -repeat $2
      (0,1,2,3,4,5) -n[-1] 32,224 6,1,1,2,128 -noise[-1] $4,0 -c[-1] 0,255 -a[-2,-1] c -ycbcr2rgb[-1] --map[0] [-1] -rm[-2]
    -done -done -append_tiles[1--1] $1,$2 -rm[0] -endl
  -mv[-1] 0 -done -v+

#@gmic cubism : '_nb_iter>=0,_bloc_size>0,_max_angle,_opacity,_smoothness>=0' : Apply cubism effect on selected images.
cubism : -skip ${1=160},${2=10},${3=75},${4=0.7},${5=0}
  -e "Apply cubism effect on image$?, with $1 iterations, bloc size $2%, maximum angle $3, opacity $4 and smoothness $5."
  -v- -type float -repeat @#
    -p {$2*max(@{-1,w},@{-1,h})/200}
    -repeat $1
      ({?(0,@{-1,w})},{?(0,@{-1,h})})
      --crop[-2] {@{-1,0}-@{*,-1}},{@{-1,1}-@{*,-1}},{@{-1,0}+@{*,-1}},{@{-1,1}+@{*,-1}}
      -blur[-1] $5 --f[-1] 1 -rotate[-2,-1] {?(-$3,$3)},0,0
      -image[-4] [-2],{@{-3,0}-@{*,-1}},{@{-3,1}-@{*,-1}},0,$4,[-1] -rm[-3--1]
    -done
    -pp[-1]
  -mv[-1] 0 -done -v+

#@gmic glow : '_amplitude>=0' : Add soft glow on selected images.
glow : -skip ${1=-1}
  -e "Add soft glow on image$?, with amplitude $1."
  -v- -type float -repeat @#
    --blur[-1] $1 -n[-1] [-2] -compose_edges[-2,-1] 1
  -mv[-1] 0 -done -v+

#@gmic old_photo : : Apply old photo effect on selected images.
old_photo :
  -e "Apply old photo effect on image$?."
  -v- -noise 20 -bilateral 30,60 -blur 2 -sharpen 100 -frame_fuzzy 20,20,6,3 -damp_patch 0.75 -n 0,255 -sepia -v+

#@gmic lic : _amplitude>0,_channels>0 : Generate LIC representation of vector field.
lic : -skip ${1=30},${2=1}
  -e "Generate LIC representation of 2D vector field$?, with amplitude $1 and $2 channel(s)."
  -v- -type float -repeat @#
     -channels[-1] 0,1 -/[-1] {max(abs(@{-1,m}),abs(@{-1,M}))} -to_tensors[-1]
     100%,100%,100%,$2 -rand[-1] 0,255 -smooth[-1] [-2],$1 -rm[-2]
     -equalize[-1] 256
  -mv[-1] 0 -done -v+

#-------------------------
#
# Color filters
#
#-------------------------

#@gmic to_gray : : Force selected images to be in GRAY mode.
to_gray :
  -e "Force image$? to be in GRAY mode."
  -v- -repeat @#
    -if {@{-1,s}>=3} -channels[-1] 0,2 -luminance[-1]
    -elif {@{-1,s}==2} -r[-1] 100%,100%,100%,1,0
    -endif
  -mv[-1] 0 -done -v+

#@gmic to_graya : : Force selected images to be in GRAYA mode.
to_graya :
  -e "Force image$? to be in GRAYA mode."
  -v- -repeat @#
    -if {@{-1,s}>=4} --channels[-1] 3 -r[-2] 100%,100%,100%,3,0 -luminance[-2] -a[-2,-1] c
    -elif {@{-1,s}==3} -luminance[-1] 100%,100%,100%,1,255 -a[-2,-1] c
    -elif {@{-1,s}==1} 100%,100%,100%,1,255 -a[-2,-1] v
    -endif
  -mv[-1] 0 -done -v+

#@gmic to_rgb : : Force selected images to be in RGB mode.
to_rgb :
  -e "Force image$? to be in RGB mode."
  -v- -repeat @#
    -if {@{-1,s}>3} -channels[-1] 0,2
    -elif {@{-1,s}==2} -r[-1] 100%,100%,100%,1,0 -r[-1] 100%,100%,100%,3
    -elif {@{-1,s}==1} -r[-1] 100%,100%,1,3
    -endif
  -mv[-1] 0 -done -v+

#@gmic to_rgba : : Force selected images to be in RGBA mode.
to_rgba :
  -e "Force image$? to be in RGBA mode."
  -v- -repeat @#
    -if {@{-1,s}>4} -channels[-1] 0,3
    -elif {@{-1,s}==3} 100%,100%,1,1,255 -a[-2,-1] c
    -elif {@{-1,s}==2} -s[-1] c -r[-2] 100%,100%,100%,3 -a[-2,-1] c
    -elif {@{-1,s}==1} -r[-1] 100%,100%,1,3 100%,100%,1,1,255 -a[-2,-1] c
    -endif
  -mv[-1] 0 -done -v+

#@gmic to_colormode : 'mode={0=unchanged,1=G,2=GA,3=RGB,4=RGBA}' : Force selected images to be in a given color mode.
to_colormode : -skip ${1=0}
  -if {$1==1} -to_gray
  -elif {$1==2} -to_graya
  -elif {$1==3} -to_rgb
  -elif {$1==4} -to_rgba
  -endif

#@gmic remove_opacity : : Remove opacity channel of selected images.
remove_opacity :
  -e "Remove opacity channel of image$?."
  -v- -repeat @#
    -if {@{-1,s}==2} -r[-1] 100%,100%,100%,1,0
    -elif {@{-1,s}==4} -r[-1] 100%,100%,100%,3,0
    -endif
  -mv[-1] 0 -done -v+

#@gmic select_color : '_tolerance[%]>=0,col1,...,colN' : Select pixels with specified color in selected images.
select_color : -skip ${1=0}
  -e "Select color (${2*}) in image$?, with tolerance $1."
  -v- -type float -repeat @#
    (${2*}) -unroll[-1] c -to_colormode[-1] @{-2,s}
    -r[-1] [-2] --[-2,-1] -norm[-1] -t[-1] $1 -*[-1] -1 -+[-1] 1
  -mv[-1] 0 -done -v+

#@gmic replace_color : '_tolerance[%]>=0,_smoothness[%]>=0,src1,...,srcN,dest1,...,destN' : Replace pixels from/to specified colors in selected images.
replace_color : -skip ${1=0},${2=0}
  -e "Replace colors in image$?, with tolerance $1 and smoothness $2."
  -v- -type float -repeat @#
    (${3*}) -unroll[-1] c -s[-1] c,2 -to_colormode[-2,-1] @{-3,s} --[-1] [-2]
    -r[-2] [-3] --[-2] [-3] -norm[-2] -t[-2] $1 -blur[-2] $2 -*[-2] -1 -+[-2] 1
    -r[-2] [-3] -r[-1] [-2] -*[-2,-1] -+[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic fill_color : 'col1,...,colN' : Fill selected images with specified color.
fill_color :
  -e "Fill image$? with color ($*)."
  -v- -repeat @#
    ($*) -unroll[-1] c -to_colormode[-1] @{-2,s}
    (@{-2,w},@{-2,h},@{-2,d}) -rm[-3] -r[-2] @-1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic luminance : : Compute luminance of selected images.
luminance :
  -e "Compute luminance of image$?."
  -v- -to_rgb -rgb2ycbcr -channels 0 -v+

#@gmic mix_rgb : 'a11,a12,a13,a21,a22,a23,a31,a32,a33' : Apply 3x3 specified matrix to RGB colors of selected images.
mix_rgb : -skip ${1=1},${2=0},${3=0},${4=0},${5=1},${6=0},${7=0},${8=0},${9=1}
  -e "Apply matrix [ $1 $2 $3 ; $4 $5 $6 ; $7 $8 $9 ] to RGB colors of image$?."
  -v- -type float -repeat @#
    -r[-1] 100%,100%,1,3,0,2 -s[-1] c
    --*[-3] $4 --*[-3] $5 -+[-1,-2] --*[-2] $6 -+[-1,-2]
    --*[-4] $7 --*[-4] $8 -+[-1,-2] --*[-3] $9 -+[-1,-2]
    -*[-5] $1 -*[-4] $2 -*[-3] $3 -+[-5--3] -a[-3--1] v
  -mv[-1] 0 -done -v+

#@gmic apply_gamma : 'gamma' : Apply gamma correction to selected images.
apply_gamma : -skip ${1=1.2}
  -e "Apply Gamma-correction to image$?, with gamma $1."
  -v- -type float -repeat @#
    (@{-1,m},@{-1,M}) -n[-2] 0,1 -pow[-2] {1/$1} -n[-2] @-1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic solarize : : Solarize selected images.
solarize :
  -e "Solarize image$?."
  -v- -luminance -n 0,128 -map 1 -v+

#@gmic sepia : : Apply sepia tones effect on selected images.
sepia :
  -e "Apply sepia tones effect on image$?."
  -v- -luminance (0,44,115,143,196,244^0,20,84,119,184,235^0,5,44,73,144,200)
  -r[-1] 256,1,1,3,3 -map[0--2] [-1] -rm[-1] -v+

#@gmic negative : : Compute negative of selected images.
negative :
  -e "Compute negative of image$?."
  -v- -repeat @#
    --[-1] @{-1,M} -*[-1] -1
  -mv[-1] 0 -done -v+

#@gmic split_tones : 'N>0' : Split selected images into N tones.
split_tones : -skip ${1=3}
  -e "Split image$? into $1 tones."
  -v- -quantize $1 -n 1,$1 -round 1 --[-1] 1
  -repeat @#
    -l[-1] -repeat $1
      ---[0] @{>,-1} -abs[-1] -t[-1] 0.1 -negative[-1]
    -done -rm[0] -endl
  -mv[-$1--1] 0 -done -v+

#@gmic split_opacity : '' : Split color and opacity parts of selected images.
split_opacity :
  -e "Split color and opacity parts of image$?."
  -v- -repeat @#
    -if {@{-1,s}==2} -s[-1] c -mv[-2,-1] 0
    -elif {@{-1,s}==4} -s[-1] c -a[-4--2] c -mv[-2,-1] 0
    -else -mv[-1] 0
    -endif
  -done -v+

#@gmic red_eye : '0<=_threshold<=100,_smoothness>=0,0<=attenuation<=1' : Attenuate red-eye effect in selected images.
red_eye : -skip ${1=75},${2=3.5},${3=0.1}
  -e "Attenuate red-eye effect in image$?, with threshold $1, smoothness $2 and attenuation $3."
  -v- -type float -to_rgb -rgb2ycbcr -repeat @#
    -s[-1] c --[-1] 128 --t[-1] $1% -blur[-1] $2 -sqrt[-1] -*[-1] -1 -+[-1] 1
    -n[-1] $3,1 -*[-2,-1] -+[-1] 128 -a[-3--1] c -ycbcr2rgb[-1]
  -mv[-1] 0 -done -v+

#@gmic threshold2 : '_min,_max' : Threshold selected images between the two given values.\n         (eq. to '-t2').
threshold2 : -skip ${1=0%},${2=100%}
  -e "Hard-threshold image$? between values $1 and $2."
  -v-
  -repeat @#
    --threshold[-1] $1 -threshold[-2] $2 -xor[-2,-1]
  -mv[-1] 0 -done -v+

t2 : -threshold2 $*

#-------------------------
#
# Image fading
#
#-------------------------

#@gmic fade_x : '0<=_start<=100,0<=_end<=100' : Create horizontal fading from selected images.
fade_x : -skip ${1=30},${2=70}
  -e "Create ($1%,$2%) horizontal fading from image$?."
  -v- -repeat {@#/2}
    (0,1) -_fade $1,$2
  -mv[-1] 0 -done -v+

#@gmic fade_y : '0<=_start<=100,0<=_end<=100' : Create vertical fading from selected images.
fade_y : -skip ${1=30},${2=70}
  -e "Create ($1%,$2%) vertical fading from image$?."
  -v- -repeat {@#/2}
    (0;1) -_fade $1,$2
  -mv[-1] 0 -done -v+

#@gmic fade_z : '0<=_start<=100,0<=_end<=100' : Create transversal fading from selected images.
fade_z : -skip ${1=30},${2=70}
  -e "Create ($1%,$2%) transversal fading from image$?."
  -v- -repeat {@#/2}
    (0/1) -_fade $1,$2
  -mv[-1] 0 -done -v+

#@gmic fade_radial : '0<=_start<=100,0<=_end<=100' : Create radial fading from selected images.
fade_radial : -skip ${1=30},${2=70}
  -e "Create ($1%,$2%) radial fading from image$?."
  -v- -repeat {@#/2}
    100%,100% -point 50%,50%,0,1,1 -distance[-1] 1 -_fade $1,$2
  -mv[-1] 0 -done -v+

#@gmic fade_diamond : '0<=_start<=100,0<=_end<=100' : Create diamond fading from selected images.
fade_diamond : -skip ${1=70},${2=90}
  -e "Create ($1%,$2%) diamond-shaped fading from image$?."
  -v- -repeat {@#/2}
    (0,1,0;1,1,1;0,1,0) -_fade $1,$2
  -mv[-1] 0 -done -v+

#@gmic fade_linear : '_angle,0<=_start<=100,0<=_end<=100' : Create linear fading from selected images.
fade_linear : -skip ${1=45},${2=30},${3=70}
  -e "Create ($2%,$3%) linear fading from image$?, with angle $1."
  -v- -repeat {@#/2}
     64,64,1,1,"x*cos($1*pi/180)+y*sin($1*pi/180)" -_fade $2,$3
  -mv[-1] 0 -done -v+

_fade :
  -type float -r[-2] [-3],5 -r[-1] [-2],3 -c[-1] $1%,$2% -n[-1] 0,1 --*[-1] -1 -+[-1] 1 -*[-4,-1] -*[-2,-1] -+[-2,-1]

#-------------------------
#
# Image composition
#
#-------------------------

#@gmic compose_rgba : : Compose selected RGBA images two-by-two, over RGB background.
compose_rgba :
  -e "Compose RGBA image$? two-by-two, over RGB background."
  -v- -type float -repeat {@#/2}
    -to_rgb[-2] -r[-1] [-2],[-2],1,100% -to_rgba[-1]
    -s[-1] c -a[-4--2] c -/[-1] 255 [-1] -negative[-1] -r[-4--1] 100%,100%,1,3
    -*[-4,-1] -*[-2,-1] -+[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic compose_average : : Compose selected images two-by-two, using average mode.
compose_average :
  -e "Compose image$? two-by-two, using average mode."
  -v- -remove_opacity -to_colormode[0--1] @{0,s} -type float -repeat {@#/2}
    -r[-1] [-2],0 -+[-2,-1] -/[-1] 2
  -mv[-1] 0 -done -v+

#@gmic compose_multiply : : Compose selected images two-by-two, using multiply mode.
compose_multiply :
  -e "Compose image$? two-by-two, using multiply mode."
  -v- -remove_opacity -to_colormode[0--1] @{0,s} -type float -repeat {@#/2}
    -r[-1] [-2],0 -*[-2,-1] -/[-1] 256
  -mv[-1] 0 -done -v+

#@gmic compose_screen : : Compose selected images two-by-two, using screen mode.
compose_screen :
  -e "Compose image$? two-by-two, using screen mode."
  -v- -remove_opacity -to_colormode[0--1] @{0,s} -type float -repeat {@#/2}
    -r[-1] [-2],0 --[-2,-1] 255 -*[-2,-1] -/[-1] 256 --[-1] 255 -*[-1] -1
  -mv[-1] 0 -done -v+

#@gmic compose_darken : : Compose selected images two-by-two, using darken mode.
compose_darken :
  -e "Compose image$? two-by-two, using darken mode."
  -v- -remove_opacity -to_colormode[0--1] @{0,s} -type float -repeat {@#/2}
    -r[-1] [-2],0 -min[-2] [-1] -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic compose_lighten : : Compose selected images two-by-two, using lighten mode.
compose_lighten :
  -e "Compose image$? two-by-two, using lighten mode."
  -v- -remove_opacity -to_colormode[0--1] @{0,s} -type float -repeat {@#/2}
    -r[-1] [-2],0 -max[-2] [-1] -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic compose_difference : : Compose selected images two-by-two, using difference mode.
compose_difference :
  -e "Compose image$? two-by-two, using difference mode."
  -v- -remove_opacity -to_colormode[0--1] @{0,s} -type float -repeat {@#/2}
    -r[-1] [-2],0 --[-2,-1] -abs[-1]
  -mv[-1] 0 -done -v+

#@gmic compose_negation : : Compose selected images two-by-two, using negation mode.
compose_negation :
  -e "Compose image$? two-by-two, using negation mode."
  -v- -remove_opacity -to_colormode[0--1] @{0,s} -type float -repeat {@#/2}
    -r[-1] [-2],0 -+[-2,-1] --[-1] 255 -abs[-1] --[-1] 255 -*[-1] -1
  -mv[-1] 0 -done -v+

#@gmic compose_exclusion : : Compose selected images two-by-two, using exclusion mode.
compose_exclusion :
  -e "Compose image$? two-by-two, using exclusion mode."
  -v- -remove_opacity -to_colormode[0--1] @{0,s} -type float -repeat {@#/2}
    -r[-1] [-2],0 --*[-2] [-1] -/[-1] -128 -+[-3--1]
  -mv[-1] 0 -done -v+

#@gmic compose_overlay : : Compose selected images two-by-two, using overlay mode.
compose_overlay :
  -e "Compose image$? two-by-two, using overlay mode."
  -v- -remove_opacity -to_colormode[0--1] @{0,s} -type float -repeat {@#/2}
    -r[-1] [-2],0
    --t[-2] 128
    --*[-3] [-2] -/[-1] 128
    --[-4,-3] 255 -*[-4,-3] -/[-3] 128 --[-3] 255 -*[-3] -1
    -*[-3] [-2] -*[-2] -1 -+[-2] 1 -*[-2,-1]
    -+[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic compose_hardlight : : Compose selected images two-by-two, using hard light mode.
compose_hardlight :
  -e "Compose image$? two-by-two, using hard light mode."
  -v- -remove_opacity -to_colormode[0--1] @{0,s} -type float -repeat {@#/2}
    -r[-1] [-2],0
    --t[-1] 128
    --*[-3] [-2] -/[-1] 128
    --[-4,-3] 255 -*[-4,-3] -/[-3] 128 --[-3] 255 -*[-3] -1
    -*[-3] [-2] -*[-2] -1 -+[-2] 1 -*[-2,-1]
    -+[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic compose_softlight : : Compose selected images two-by-two, using soft light mode.
compose_softlight :
  -e "Compose image$? two-by-two, using soft light mode."
  -v- -remove_opacity -to_colormode[0--1] @{0,s} -type float -repeat {@#/2}
    -r[-1] [-2],0 -/[-2,-1] 256 --*[-2] [-1] -*[-1] 2 -sqr[-3] -*[-2] [-3] -*[-2] -2 -+[-3--1] -*[-1] 256
  -mv[-1] 0 -done -v+

#@gmic compose_dodge : : Compose selected images two-by-two, using dodge mode.
compose_dodge :
  -e "Compose image$? two-by-two, using dodge mode."
  -v- -remove_opacity -to_colormode[0--1] @{0,s} -type float -repeat {@#/2}
    -r[-1] [-2],0 --[-1] 255.1 -/[-2,-1] -*[-1] -256 -c[-1] 0,255
  -mv[-1] 0 -done -v+

#@gmic compose_colorburn : : Compose selected images two-by-two, using color burn mode.
compose_colorburn :
  -e "Compose image$? two-by-two, using colorburn mode."
  -v- -remove_opacity -to_colormode[0--1] @{0,s} -type float -repeat {@#/2}
    -r[-1] [-2],0 --[-2] 255 -+[-1] 0.1 -/[-2,-1] -*[-1] 256 -+[-1] 255 -c[-1] 0,255
  -mv[-1] 0 -done -v+

#@gmic compose_reflect : : Compose selected images two-by-two, using reflect mode.
compose_reflect :
  -e "Compose image$? two-by-two, using reflect mode."
  -v- -remove_opacity -to_colormode[0--1] @{0,s} -type float -repeat {@#/2}
    -r[-1] [-2],0 -sqr[-2] --[-1] 255.1 -/[-2,-1] -*[-1] -1 -c[-1] 0,255
  -mv[-1] 0 -done -v+

#@gmic compose_freeze : : Compose selected images two-by-two, using freeze mode.
compose_freeze :
  -e "Compose image$? two-by-two, using freeze mode."
  -v- -remove_opacity -to_colormode[0--1] @{0,s} -type float -repeat {@#/2}
    -r[-1] [-2],0 --[-2] 255 -sqr[-2] -+[-1] 0.1 -/[-2,-1] --[-1] 255 -*[-1] -1 -c[-1] 0,255
  -mv[-1] 0 -done -v+

#@gmic compose_stamp : : Compose selected images two-by-two, using stamp mode.
compose_stamp :
  -e "Compose image$? two-by-two, using stamp mode."
  -v- -remove_opacity -to_colormode[0--1] @{0,s} -type float -repeat {@#/2}
    -r[-1] [-2],0 -*[-1] 2 -+[-2,-1] --[-1] 255 -c[-1] 0,255
  -mv[-1] 0 -done -v+

#@gmic compose_interpolation : : Compose selected images two-by-two, using interpolation mode.
compose_interpolation :
  -e "Compose image$? two-by-two, using interpolation mode."
  -v- -remove_opacity -to_colormode[0--1] @{0,s} -type float -repeat {@#/2}
    -r[-1] [-2],0 -*[-2,-1] 0.012271846 -cos[-2,-1] -/[-2,-1] -4 -+[-2,-1] -+[-1] 0.5 -*[-1] 256
  -mv[-1] 0 -done -v+

#@gmic compose_xor : : Compose selected images two-by-two, using xor mode.
compose_xor :
  -e "Compose image$? two-by-two, using xor mode."
  -v- -remove_opacity -to_colormode[0--1] @{0,s} -type float -repeat {@#/2}
    -r[-1] [-2],0 -xor[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic compose_edges : 'smoothness=0.8' : Compose selected images togethers using edge composition.
compose_edges : -skip ${1=0.8}
  -e "Compose image$? using edge composition, with smoothness $1."
  -if {@#>1} -v- -to_rgb -type float -repeat @#
    --gradient_norm[-1] -+[-1] 1 -blur[-1] $1 -n[-1] 1,10 -sqr[-1] -s[-2] c -*[-4--2] [-1] -a[-4--1] c
  -mv[-1] 0 -done -r[1--1] [0],0,0,1 -+ -s[-1] c -/[-4--2] [-1] -rm[-1] -a[-3--1] c -v+ -endif

#-------------------------
#
# Motion related filters
#
#-------------------------

#@gmic cross_correlation : : Compute cross-correlation using two-by-two selected images.
cross_correlation :
  -e "Compute cross-correlation using two-by-two image$?."
  -v- -type float -repeat {@#/2}
    -norm[-2,-1] -fft[-2] -fft[-1] [-2,-1] -mul[-2] [-5] -mul[-1] [-6]
    --[-2,-1] -*[-5,-3] -*[-3,-2] -+[-3,-2] -ifft[-2,-1] -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic normalized_cross_correlation : : Compute normalized cross-correlation using two-by-two selected images.
normalized_cross_correlation :
  -e "Compute normalized cross-correlation using two-by-two image$?."
  -v- -type float -repeat {@#/2}
    -norm[-2,-1] -fft[-2] -fft[-1] [-2,-1] -mul[-2] [-5] -mul[-1] [-6]
    --[-2,-1] -*[-5,-3] -*[-3,-2] -+[-3,-2] [-2,-1] -a[-2,-1] c -norm[-1]
    -/[-3] [-1] -/[-2,-1] -ifft[-2,-1] -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic phase_correlation : : Estimate translation vector using two-by-two selected images.
phase_correlation :
  -e "Estimate translation vector using two-by-two image$?."
  -v- -type float -repeat {@#/2}
    -normalized_cross_correlation[-2,-1]
    (@{-1,C}) -*[-1] 2 -s[-1] x -rm[-1]
    -if {@-3>@{-4,w}} --[-3] @{-4,w} --[-3] @{-4,w} -endif
    -if {@-2>@{-4,h}} --[-2] @{-4,h} --[-2] @{-4,h} -endif
    -if {@-1>@{-4,d}} --[-1] @{-4,d} --[-1] @{-4,d} -endif
    -a[-3--1] c -/[-1] 2 -*[-1] -1 -rm[-2]
  -mv[-1] 0 -done -v+

#@gmic morph : 'nb_frames>0,_smoothness>=0,_precision>0' : Create morphing sequence between selected images.
morph : -skip $1,${2=0.2},${3=0.1}
  -e "Create morphing sequence between image$?, with $1 intra-frames, smoothness $2 and precision $3."
  -v- -type float -r[1--1] [0],3 -i[0] (@#) --[0] 1 -repeat @0
    --equalize[-2,-1] 256 -n[-2,-1] 0,255
    --displacement[-2] [-1],$2,$3 --warp[-5] [-1],1,1,1,$1 -a[-$1--1] z -rm[-2]
    --displacement[-2] [-3],$2,$3 --warp[-5] [-1],1,1,1,$1 -a[-$1--1] z -rm[-7--4,-2]
    (1/0) -r[-1] [-2],3 -*[-3] [-1] -*[-2,-1] -mirror[-1] z -+[-2,-1] -s[-1] z
    -mv[-$1--1] 1 -mv[1] @#
  -done -mv[-1] 1 -rm[0] -v+

#@gmic register_nonrigid : '_smoothness>=0,_precision>0,_nb_scale>=0' : Register selected images with non-rigid warp.
register_nonrigid : -skip ${1=0.2},${2=0.1},${3=0}
  -e "Register image$? with non-rigid warp, smoothness $1, precision $2 and $3 scale(s)."
  -v- -type float --equalize[0] 256 -n[-1] 0,255 -mv[-1] 1
  -repeat @# -if {@{>,-1}>1}
    --equalize[-1] 256 -n[-1] 0,255 -displacement[-1] [1],$1,$2,$3
    -warp[-2] [-1],1,1,1 -rm[-1]
  -mv[-1] 2 -endif -done -rm[1] -v+

#@gmic register_rigid : '_smoothness>=0' : Register selected images with rigid warp.
register_rigid : -skip ${1=1}
  -e "Register image$? with rigid warp and smoothness $1."
  -v- -type float --equalize[0] 256 -blur[-1] $1 -n[-1] 0,255 -mv[-1] 1
  -repeat @# -if {@{>,-1}>1}
    --equalize[-1] 256 -blur[-1] $1 -n[-1] 0,255 --phase_correlation[1,-1] -rm[-2] -*[-1] -1
    -shift[-2] @-1,0,1 -rm[-1]
  -mv[-1] 2 -endif -done -rm[1] -v+

#-------------------------
#
# Video related filters
#
#-------------------------

#@gmic deinterlace : '_method={0|1}' : Deinterlace selected images ('method' can be { 0=standard or 1=motion-compensated }).
deinterlace : -skip ${1=0}
  -if $1 -e "Deinterlace image$? with motion-compensated method."
  -else  -e "Deinterlace image$? with standard method."
  -endif
  -v- -type float -repeat @#
    -i[-2] (@{-1,w},@{-1,h})
    -if {$1==0}
      -l[-1] -s y -a[0--1:2] y -a[1--1] y -r[-2] [-1],0 -r[-2,-1] 100%,200%,100%,100%,5 -+[-2,-1] -/[-1] 2 -endl
    -else
      -l[-1] -s y -a[0--1:2] y -a[1--1] y -r[-2] [-1],0 -r[-2,-1] 100%,200%,1,100%,5
      --displacement[-2] [-1],0.05 -warp[-3] [-1],1,1,1 -rm[-1] -+[-2,-1] -/[-1] 2 -endl
    -endif
    -r[-1] @-2 -rm[-2]
  -mv[-1] 0 -done -v+

#-------------------------
#
#  3D-related filters
#
#-------------------------

#@gmic animate3d : '_width>0,_height>0,_dx,_dy,_dz' : Animate selected 3D objects in a window.
animate3d : -skip ${1=640},${2=480},${3=0},${4=10},${5=0}
  -e "Animate 3D object$?, in a $1x$2 window with angle velocities ($3,$4,$5)."
  -v- -repeat @#
    --n3d[@{>,-1}] -*3d[-1] {min($1,$2)/1.7} -c3d[-1] (0,0,0)
    -do
       --rot3d[-2] 1,0,0,@{-1,0} -rot3d[-1] 0,1,0,@{-2,1} -rot3d[-1] 0,0,1,@{-2,2} ($3,$4,$5) -+[-3,-1]
       $1,$2,1,3,64 -object3d[-1] [-2],50%,50%,0,1
       -name[-1] [@{>,-1}] -w[-1] @{-1,w},@{-1,h},0 -wait 20 -rm[-2,-1]
    -while {"@! && !@{!,ESC} && !@{!,Q}"} -rm[-1] -w 0
  -done -v+

#@gmic imagecube3d : '_resolution>0' : Create 3D mapped cubes from selected images.
imagecube3d : -skip ${1=128}
  -e "Generate 3D mapped cube from image$?, with resolution $1."
  -v- -repeat @#
    -r[-1] $1,$1,1,100%,2 -mirror[-1] x -elevation3d[-1] 0 -c3d[-1] -n3d[-1] -+3d[-1] 0,0,0.5 --rot3d[-1] 0,1,0,180
    -+3d[-2,-1] --rot3d[-1] 0,1,0,90 --rot3d[-2] 1,0,0,90 -+3d[-3--1] -r3d[-1]
  -mv[-1] 0 -done -v+

#@gmic text3d : '"text",_size>0,_depth>0,_smoothness' : Create a 3D text object from specified text.
text3d : -skip ${2=128},${3=10},${4=1.5}
  -e "Generate 3D text object '"$1"' with size $2, depth $3 and smoothness $4."
  -v- 256,256,1,1 -text[-1] $1,0,0,$2,1,1 -autocrop[-1] 0
  -r[-1] 100%,100%,$3 -r[-1] {@{-1,w}+12},{@{-1,h}+12},{@{-1,d}+12},1,0,0,1
  -blur[-1] $4 -n[-1] 0,1 -isosurface3d[-1] 0.5 -r3d[-1] -v+

#@gmic gmic3d : : Create a 3D gmic logo.
gmic3d :
  -e "Generate 3D G'MIC logo."
  -v-
  -text3d G,40,20,4 -col3d[-1] 16,64,255
  -text3d \',40,20,4 -+3d[-1] 30 -col3d[-1] 64,128,255
  -text3d M,40,20,2 -+3d[-1] 40 -col3d[-1] 96,196,255
  -text3d I,40,20,4 -+3d[-1] 70 -col3d[-1] 64,128,255
  -text3d C,40,20,4 -+3d[-1] 95 -color3d[-1] 16,64,255
  -sphere3d 8 -+3d[-1] 85,-10,15 -col3d[-1] 192,128,255
  -+3d[-6--1] -c3d[-1]
  -repeat 30
    -box3d {min(3+@{<,-1}/2,10)} -col3d[-1] {30*@{>,-1}},{20+80*@{>,-1}},{10*@{>,-1}},0.5
    -rot3d[-1] 1,1,1,{@{>,-1}*12}
    -+3d[-1] {80*cos(0.5+1.02*@{>,-1}*12*pi/180)},{30*sin(0.8+@{>,-1}*12*pi/180)},{2*@{>,-1}-75}
  -done
  -+3d[-30--1] -+3d[-1] 0,5,30 -+3d[-2--1]
  -v+

#-------------------------
#
# Other various filters
#
#-------------------------

#@gmic animate : 'filter_name,(params_start;..;..),(params_end;..;..),nb_frames>=0,_output_frames={0|1},_output_files={0|1},_filename' : Animate filter from starting parameters to ending parameters.
animate : -skip ${5=1},${6=0},${7=gmic}
  -e "Compute animated version of filter '$1', from parameters $2 to $3 with $4 frames."
  -if {!($5||$6)} -return -endif
  -v- -type float
  -i[0] $2 -i[1] $3 -a[0,1] x -r[0] $4,100%,1,1,3
  -progress 0 -repeat {@#-1} --l[0,1]
    -repeat $4
      --columns[0] @{>,-1} -mv[-1] 0
      --l[0,2] -$1[1] @0 -rm[0]
      -if $6 -o $7@{>,-2}_{round(@{>,-1}/1000,1,-1)%10}{round(@{>,-1}/100,1,-1)%10}{round(@{>,-1}/10,1,-1)%10}{@{>,-1}%10}.png -endif
      -endl -rm[0]
      -if {!$5} -rm[-1] -endif
      -progress {100*(@{>,-1}+1)/$4}
    -done -rm[0] -if $5 -rm[0] -endif
  -endl -rm[1] -done -rm[0] -v+


#@gmic x_mandelbrot : '_julia={0|1},_c0r,_c0i' : Launch Mandelbrot/Julia explorer.
x_mandelbrot : -skip ${1=0},${2=0.317},${3=0.03}
  -e "\n\
------ Launch Mandelbrot/Julia explorer -------\n\
----\n\
---- Select zooming region with mouse.\n\
---- Click to reset to original zoom.\n\
---- Keys 'ESC' or 'Q' exit.\n\
---- Key 'C' prints current fractal coordinates.\n\
----\n\
------------------------------------------------"

  # Init variables and display.
  -v- -type float
  -rm -w 512,512,0,0 -_x_mandelbrot_coords $1 -_x_mandelbrot_palette

  # Start event loop.
  -do
    -p {min(@{!,w},@{!,h})}                                                                               # Push desired window dimension.
    @{*,-1},@{*,-1} -mandelbrot[-1] @0,256,$1,{if($1,$2,0)},{if($1,$3,0)} -map[-1] [1]                    # Render fractal.
    -if $1 -name[-1] "Julia set c=(@{0,0},@{0,1})-(@{0,2},@{0,3}), c0=($2,$3)" -w[-1] @{*,-1},@{*,-1},0,0 # Display on window.
    -else -name[-1] "Mandelbrot set c=(@{0,0},@{0,1})-(@{0,2},@{0,3})" -w[-1] @{*,-1},@{*,-1},0,0 -endif
    -p @{-1,w} -p @{-1,h} -select[-1] 2                                                                   # Get the user selection.

    -if {@{-1,0}>0}                                                                      # If valid selection found.
      -p {max(@{-1,3}-@{-1,0},@{-1,4}-@{-1,1})}                                          # Compute max dimension of selected rectangle.
      -if {@{*,-1}<5} -_x_mandelbrot_coords $1 -rm[1] -_x_mandelbrot_palette -mv[-1] 1   # If selection too small, reset the view,
      -else ({"@{0,0} + @{-1,0}*(@{0,2} - @{0,0})/@{*,-3}"};\                            # Else compute new fractal coordinates.
             {"@{0,1} + @{-1,1}*(@{0,3} - @{0,1})/@{*,-2}"};\
             {"@{0,0} + (@{-1,0} + @{*,-1})*(@{0,2} - @{0,0})/@{*,-3}"};\
             {"@{0,1} + (@{-1,1} + @{*,-1})*(@{0,3} - @{0,1})/@{*,-2}"})
      -endif
      -pp[-1] -rm[0] -mv[-1] 0                                                  # Validate new coordinates.
    -endif
    -rm[-1]                                                                     # Delete latest rendering.
    -if {@{!,C}} -v+                                                            # If 'C' key has been pressed.
      -if $1 -e "Julia set, at c = (@{0,0-1})-(@{0,2-3}), with c0 = ($2,$3)."
      -else -e "Mandelbrot set, at c = (@{0,0-1})-(@{0,2-3})."
      -endif
    -v- -endif
    -pp[-3--1]
    -if {"!@! || @{!,ESC} || @{!,Q}"} -rm -w 0 -v+ -return -endif
    -wait -1
  -while 1

_x_mandelbrot_coords :
  -if $1 (-2;-2;2;2) -else (-2.1;-1.5;1.2;1.5) -endif

_x_mandelbrot_palette :
  6,1,1,3 -rand[-1] 20,255 -r[-1] 32,1,1,3,3 -r[-1] 1024,1,1,3,0,2 -=[-1] 0,0,0,0,0 -=[-1] 0,0,0,0,1 -=[-1] 0,0,0,0,2

#@gmic x_fish_eye : : Launch fish-eye demo.
x_fish_eye :
  -e "\n\
------ Launch G'MIC fish-eye demo -------\n\
----\n\
---- Mouse pointer moves fish-eye center.\n\
---- Mouse buttons set fish-eye size.\n\
---- Keys 'ESC' or 'Q' exit.\n\
----\n\
-----------------------------------------"

  -v- -type float
  -if {@#>0} -a x -n 0,255 -r2dy 220 -else
  120,90,1,3 -rand[-1] 0,255 -plasma[-1] 0.3,3 -n 0,255
  -text "  G'MIC\nFISH-EYE\n  DEMO",15,13,24,1,255 -resize2x -blur 5 -sharpen 1000
  -f i+150-4*abs(y-h/2) -c[-1] 0,255 -frame_fuzzy[-1] 15,10,15,1.5,0 -to_rgb[-1]
  -endif
  -torus3d 20,6 -col3d[-1] {?(30,255)},{?(30,255)},{?(30,255)} --rot3d[-1] 1,0,0,90
  -col3d[-1] {?(30,255)},{?(30,255)},{?(30,255)} -+3d[-1] 15 -+3d[-2,-1] -db3d 0 -c3d[-1]
  -p[0] 30
  -w[-2] {2*@{-2,w}},{2*@{-2,h}},0,0
  -repeat 100000
    -wait 40
    -if {@{!,b}==1} -p[0] {min(80,@{*,0}+8)} -pp[1] -endif
    -if {@{!,b}==2} -p[0] {max(3,@{*,0}-8)} -pp[1] -endif
    --object3d[-2] [-1],{50+30*cos(@{>,-1}/20)}%,{50+30*sin(@{>,-1}/31)}%,{50+330*sin(@{>,-1}/19)},0.7,0 -rot3d[-2] 1,0.2,0.6,3
    -if {@{!,x}>=0}
    -fish_eye[-1] {@{!,x}*100/@{!,w}},{@{!,y}*100/@{!,h}},@{*,0}
    -endif
    -name[-1] "Fish-Eye Demo" -w[-1] -rm[-1]
    -if {"@!==0 || @{!,ESC} || @{!,Q}"} -rm[-2,-1] -pp[0] -w 0 -v+ -return -endif
  -done

#@gmic x_spline : : Launch spline curve ditor.
x_spline :
  -e "\n\
------ Launch spline curve editor -------\n\
----\n\
---- Mouse to insert/move/delete points.\n\
---- Key 'R' resets the curve.\n\
---- Key 'SPACE' shows/hides spline curve.\n\
---- Key 'P' shows/hides control points.\n\
---- Key 'ENTER' shows/hides control polygon.\n\
---- Key 'T' shows/hides point tangents.\n\
---- Key 'I' shows/hides point indices.\n\
---- Key 'C' shows/hides point coordinates.\n\
---- Keys '+' and '-' increase/decrease roundness.\n\
---- Keys 'ESC' or 'Q' exit.\n\
----\n\
-----------------------------------------"

  # Init display and variables.
  -v- -type float
  -if @# -a x -n 0,255 -to_rgb -else (0;0^0;128^0;0) -r[-1] 512,512,1,3,3 -endif
  -w[0] @{0,w},@{0,h},0,0 -r[0] @{!,w},@{!,h},1,3,1
  -i[1] 1 # Point coordinates
  -p 0.5  # Curve sharpness
  -p 23   # Visualisation flags
  -p -1   # Nearest point
  -p -1   # Active point

  # Start event loop.
  -do

    # Init coordinates [1] if necessary.
    -if {@{1,#}==1}
      -rm[1] -pp[-4,-2,-1] -p -1 -p -1 -p[-4] 0.5
      -i[1] ({0.2*@{-1,w}},{0.2*@{-1,h}};\
             {0.2*@{-1,w}},{0.8*@{-1,h}};\
             {0.8*@{-1,w}},{0.8*@{-1,h}};\
             {0.8*@{-1,w}},{0.2*@{-1,h}})
    -endif

    # Estimate screen-normalized coordinates [2], curve tangents [3] and tangent orientations [4].
    [1] ({@{!,w}/@{0,w}},{@{!,h}/@{0,h}}) -*[-2,-1]                       # Normalized coordinates.
    --shift[2] 0,-1,0,0,2 --shift[2] 0,1,0,0,2 --[-2,-1] -*[-1] @{*,-4}   # Curve tangents.
    --s[-1] x -sqr[-2,-1] -+[-2,-1] -sqrt[-1] -r[-1] 2 --/[-2,-1] -rm[-2] # Tangent orientations.

    # Display curve, control points, polygon and tangents.
    --r[0] @{!,w},@{!,h},1,3
    -if {@{*,-3}&4} -polygon[-1] @{2,h},@2,0.3,128,200,255 -endif
    -repeat @{1,h}
      -line[-1] @{2,0-3},0.3,255,255,0
      -if {@{*,-3}&1} -spline[-1] @{2,0-1},@{3,0-1},@{2,2-3},@{3,2-3},1,255 -endif
      -if {@{*,-3}&8} -line[-1] {@{2,0}-@{4,0}*20},{@{2,1}-@{4,1}*20},{@{2,0}+@{4,0}*20},{@{2,1}+@{4,1}*20},1,0,255,0 -endif
      -if {@{*,-3}&16} -text[-1] @{>,-1},{@{2,0}-3},{@{2,1}-18},8,1,255,255,0 -endif
      -if {@{*,-3}&32} -text[-1] "({round(@{1,0})}\,{round(@{1,1})})",{@{2,0}-16},{@{2,1}+10},8,1,100,200,255 -endif
      -shift[1-4] 0,-1,0,0,2
    -done
    -if {@{*,-3}&2} -repeat @{1,h}
      -ellipse[-1] @{2,0-1},4,4,0,1,0,0,0 -ellipse[-1] @{2,0-1},2,2,0,1,255,100,155 -shift[2] 0,1,0,0,2
    -done -endif
    -name[-1] "Spline Editor" -w[-1]
    -rm[3,4,-1]
    -wait

    # Handle key events.
    -if @{!,SPACE} -p[-3] {@{*,-3}+if(@{*,-3}&1,-1,1)} -pp[-4] -wait -1 -endif                      # Show/hide spline.
    -if @{!,P} -p[-3] {@{*,-3}+if(@{*,-3}&2,-2,2)} -pp[-4] -wait -1 -endif                          # Show/hide points.
    -if @{!,ENTER} -p[-3] {@{*,-3}+if(@{*,-3}&4,-4,4)} -pp[-4] -wait -1 -endif                      # Show/hide polygon.
    -if @{!,T} -p[-3] {@{*,-3}+if(@{*,-3}&8,-8,8)} -pp[-4] -wait -1 -endif                          # Show/hide tangents.
    -if @{!,I} -p[-3] {@{*,-3}+if(@{*,-3}&16,-16,16)} -pp[-4] -wait -1 -endif                       # Show/hide indices.
    -if {"@{!,C} && !@{!,CTRLLEFT}"} -p[-3] {@{*,-3}+if(@{*,-3}&32,-32,32)} -pp[-4] -wait -1 -endif # Show/hide coordinates.
    -if {"@{!,PADADD} && @{*,-4}<1"} -p[-4] {@{*,-4}*1.1} -pp[-5] -wait -1 -endif                   # Increase roundness.
    -if {"@{!,PADSUB} && @{*,-4}>0.1"} -p[-4] {@{*,-4}*0.9} -pp[-5] -wait -1 -endif                 # Decrease roundness.
    -if {"@{!,R} && !@{!,CTRLLEFT}"} -rm[-1] -i[1] 1 -wait -1 -endif                                # Reset curve.
    -if {"@{!,CTRLLEFT} && @{!,D}"} -w[] {round(@{!,w}*1.5)},{round(@{!,h}*1.5)} -endif             # Increase window size.
    -if {"@{!,CTRLLEFT} && @{!,C}"} -w[] {round(@{!,w}/1.5)},{round(@{!,h}/1.5)} -endif             # Decrease window size.
    -if {"@{!,CTRLLEFT} && @{!,R}"} -w[] @{0,w},@{0,h} -endif                                       # Reset window size.
    -if @{!,r} -w[] -endif                                                                          # Resize window if necessary.

    # Set/unset active point.
    -if {@{!,b}==0} -pp[-1] -p[-1] -1                               # Unset active point if mouse button is released.
    -elif {"@{!,x}>=0 && @{!,b} && @{*,-1}==-1"}                    # Find new active point.
      [2] (@{!,x},@{!,y}) --[-2,-1] -sqr[-1] -s[-1] x -+[-2,-1]     # Compute distance vector to points.
      (@{-1,c}) -pp[-2] -p[-2] @{-1,1} -rm[-1]                      # Set nearest point.
      -if {@{-1,m}<64} -pp[-1] -p @{*,-1} -endif                    # Set it as active point, if near enough.
      -rm[-1]
    -endif
    -rm[2]

    # Move active point.
    -if {"@{!,b}&1 && @{!,x}>=0 && @{*,-1}!=-1"}
      -=[1] {@{!,x}*@{0,w}/@{!,w}},0,@{*,-1}
      -=[1] {@{!,y}*@{0,h}/@{!,h}},1,@{*,-1}

    # Delete nearest point.
    -elif {"@{!,b}&2 && @{!,x}>=0 && @{1,h}>3"}
      -l[1] -s y -rm[@{*,-2}] -a y -endl -wait -1

    # Insert new active point.
    -elif {"@{!,b}&1 && @{!,x}>=0"}
      -p ({@{!,x}*@{0,w}/@{!,w}},{@{!,y}*@{0,h}/@{!,h}})              # Point coordinates in the image basis.
      --shift[1] 0,-1,0,0,2 -+[-1] [1] -/[-1] 2                       # Compute center of segments.
      @{*,-1} --[-2,-1] -sqr[-1] -s[-1] x -+[-2,-1]                   # Compute distance vector to segments.
      (@{-1,c}) -p @{-1,1} -rm[-2,-1]                                 # Push nearest segment.
      -l[1] -s y -i[{@{*,-1}+1}] @{*,-2} -a y -endl                   # Insert new point at right position.
      -p {@{*,-1}+1} -pp[-4--2]                                       # Set new active point as newly inserted.
    -endif

  -while {"@! && !@{!,ESC} && !@{!,Q}"}

  # Render spline as a tertiary mask for output.
  --shift[1] 0,-1,0,0,2 --shift[1] 0,1,0,0,2 --[-2,-1] -*[-1] @{*,-4}
  [0],[0],1,1,2 -rm[0]
  -repeat @{1,h} -spline[-1] @{0,0-1},@{1,0-1},@{0,2-3},@{1,2-3},1,1 -shift[0] 0,-1,0,0,2 -shift[1] 0,-1,0,0,2 -done
  -flood[-1] 0,0,0,0,1,0

  # Exit properly.
  -pp[-4--1] -rm[0,1] -w 0 -v+

#@gmic factorial : 'N' : Print the factorial of the integer 'N'.
factorial : -skip $1
  -v- ($1) -+[-1] 1 -if @-1 (1) (1) -repeat $1 -*[-1] @-2 -+[-2] 1 -done -v+ -e "Factorial($1) = @-1" -v- -rm[-3--1]
  -else -v+ -e "Factorial($1) is undefined." -endif -v+

# Generate a 'no-preview' image.
gimp_no_preview :
  -if {@#>0} -k[0] -else 256,256,1,1,128 -endif
  118,50 -text[-1] "No preview\navailable",2,1,24,1,255 -r[-1] [-2],[-2],1,1,0,0,1 -to_colormode[-1] @{-2,s}
  (1.5,0,1.5;0,0,0;1.5,0,1.5) -r[-1] [-3],3 -*[-3,-1] -c[-2] 0,255 -or
  -skip $*


#--------------------------
#
# Define menu entries
# for the GIMP plug-in.
#
#--------------------------

# Do not forget to ucomment this entry for a deprecated version of the G'MIC plug-in !
# #@gimp <span foreground="red"><b>UPDATE INFORMATION</b></span> : gimp_logo_en, gimp_logo_en
# #@gimp : note = note{"A <b>new version</b> of the G'MIC plug-in for GIMP is available !
# #@gimp : You are strongly encouraged to download and install this updated version, by clicking on one of the following urls :"}
# #@gimp : note = note{"\n<span foreground="purple"><u>Windows version :</u></span>"}
# #@gimp : url = link{"Download G'MIC plug-in for Windows (32 bits)","http://downloads.sourceforge.net/gmic/gmic_gimp_win32.zip"}
# #@gimp : note = note{"<b>Installation </b>: unzip the archive files and copy them into folder\n
# #@gimp :              <i>C:\\Program Files\\GIMP\\lib\\gimp\\2.0\\plug-ins\</i>"}
# #@gimp : note = note{"\n<span foreground="purple"><u>Linux version :</u></span>"}
# #@gimp : url = link{"Download plug-in for Linux (32 bits)","http://downloads.sourceforge.net/gmic/gmic_gimp_linux32.zip"}
# #@gimp : url = link{"Download plug-in for Linux (64 bits)","http://downloads.sourceforge.net/gmic/gmic_gimp_linux64.zip"}
# #@gimp : note = note{"<b>Installation </b>: unzip the archive files and copy them in folder\n
# #@gimp :              <i>/usr/lib/gimp/2.0/plug-ins/</i>"}
# #@gimp : note = note{"\nNote that there will be no updated filters anymore for your current plug-in version.
# #@gimp : Installing the G'MIC plug-in for GIMP is easy and fast, so there are no reasons not for doing it :).\n\n
# #@gimp : Best regards,\n\n <i>The G'MIC team.</i>"}

#----------------------
# English translations
#----------------------

#@gimp_en <i>About</i>
#----------------------

#@gimp_en G'MIC for GIMP : gimp_logo_big_en, gimp_logo_en
#@gimp_en : note = note{"
#@gimp_en : <span foreground="purple">( <b>G</b>REYC's <b>M</b>agic <b>I</b>mage <b>C</b>onverter )</span>\n\nis proposed to you by"}
#@gimp_en : note = link("David Tschumperl\303\251","http://www.greyc.ensicaen.fr/~dtschump")
#@gimp_en : note = link{"( IMAGE Team / GREYC Laboratory - CNRS UMR 6072 )","http://www.greyc.ensicaen.fr/EquipeImage"}
#@gimp_en : note = note{"
#@gimp_en : This plug-in is based on our open-source libraries <b>G'MIC</b> and <b>CImg</b> (C++ Template Image Processing Library),
#@gimp_en : available at :"}
#@gimp_en : note = link("http://gmic.sourceforge.net/")
#@gimp_en : note = note{"and"}
#@gimp_en : note = link("http://cimg.sourceforge.net/")
#@gimp_en : note = note{"\n
#@gimp_en : If you appreciate <b>G'MIC</b>, you are welcome to send us a nice postcard from your place, at :\n\n
#@gimp_en : <small><tt>David Tschumperl&#233;,\n Laboratoire GREYC (CNRS UMR 6072), Equipe Image,\n
#@gimp_en :  6 Bd du Mar&#233;chal Juin,\n 14050 Caen Cedex / France.</tt></small>\n\n
#@gimp_en : Postcards senders automatically enter the <i>Friends Hall of Fame</i> :) !
#@gimp_en : "}
gimp_logo :
  -rm 118,44,1,1 -text "G'MIC",3,-6,64,1,255 -dilate 3 -r 100%,100%,10,1 -r 100%,100%,20,1,0,0,1 -blur 1.5 -isosurface3d 50%
  -col3d {?(150,255)},{?(150,255)},{?(150,255)}
  -sphere3d 8 -col3d[-1] {?(150,255)},{?(150,255)},{?(150,255)} -+3d[-1] 80,-6 -+3d
  -c3d[-1] -r3d -db3d 0 -m3d 4 -sl3d 0.2 -ss3d 1.3 -rot3d[-1] 1,0,0,30 -f3d 120 -*3d[-1] 1.5
  230,120,1,3 -object3d[-1] [-2],50%,30%,0,1 -rm[-2] -text $1,12%,75%,24,1,255
gimp_logo_en :
  -gimp_logo "\"Plug-in for GIMP\""
gimp_logo_big_en :
  -gimp_logo_en -resize2x -frame 1,1,255

#@gimp_en Filters design : nop, gimp_logo_en
#@gimp_en : note = note{"
#@gimp_en : <b>G'MIC</b> is an <b>open</b> image processing framework. Thus, including
#@gimp_en : <b>user-defined filters</b> into this plug-in is possible.\n\n
#@gimp_en : To do so, you need to create a <span foreground="purple" style="italic">.gmic</span>
#@gimp_en : file (do not forget the first dot !) in your <i>Home</i> folder (or <i>Applications Data/</i> on Windows).
#@gimp_en : It will be read each time the plug-in is launched, or when the <i>Refresh</i>
#@gimp_en : button (under the central pane) is pressed. It must be a regular ascii file, containing the declarations and
#@gimp_en : implementations of the filters (written in the <b>G'MIC</b> language) that will be added
#@gimp_en : to the list of available ones.\n\n
#@gimp_en : Existing filters are already defined this way.
#@gimp_en : The current implementations can be seen at :"}
#@gimp_en : note = link("http://gmic.sourceforge.net/.gmic_def")
#@gimp_en : note = note{"
#@gimp_en : Writting a new filter in <b>G'MIC</b> is not particularly awful (nor trivial) and
#@gimp_en : can be generally done in very few lines.\n\n
#@gimp_en : <span foreground="purple" underline="single">Example of a valid <i>.gmic</i> entry :</span>\n\n
#@gimp_en : <tt>#@gimp My effect : my_effect, my_effect\n
#@gimp_en : #@gimp : Sigma = float(2,0,10)\n
#@gimp_en : my_effect :\n     --blur $1 -n 0,255 -xor</tt>\n\n
#@gimp_en : By the way, you are encouraged to share your nice custom filters on the dedicated forum,
#@gimp_en : for inclusion into next releases of <b>G'MIC</b> :
#@gimp_en : "}
#@gimp_en : note = link("Go to the G'MIC forum","http://sourceforge.net/forum/forum.php?forum_id=923318")

#@gimp_en Filters update : nop, gimp_logo_en
#@gimp_en : note = note{"
#@gimp_en : Thanks to its openness, <b>G'MIC</b> is able to <b>update</b> his list of filters
#@gimp_en : from the Internet. Pushing the <i>Refresh</i> button (under the center pane)
#@gimp_en : makes <b>G'MIC</b> connect to the update server and download the latest filter definitions.
#@gimp_en : This is actually the only network operation allowed in <b>G'MIC</b>.\n\n
#@gimp_en : Technically speaking, this update procedure creates/replaces the file
#@gimp_en : <span foreground="purple" style="italic">.gmic_def.xxxx</span> in your <i>Home</i> folder
#@gimp_en : (or <i>Application Data/</i> on Windows),
#@gimp_en : where <i>xxxx</i> are the four digits of the <b>G'MIC</b> version number.
#@gimp_en : In case of connecting troubles, you can then manually do the update by retrieving the filter
#@gimp_en : definition file directly from :"}
#@gimp_en : note = link("http://www.greyc.ensicaen.fr/~dtschump/gmic_def.xxxx")
#@gimp_en : note = note{"
#@gimp_en : Just copy and rename this file as your <span foreground="purple" style="italic">.gmic_def.xxxx</span>
#@gimp_en : (do not forget the first dot, and replace the <i>xxxx</i> by your <b>G'MIC</b> version number)
#@gimp_en : and you are done.
#@gimp_en : By the way, deleting this file resets all the filters to their initial state.
#@gimp_en : "}

#---------------------
# French translations
#---------------------

#@gimp_fr <i>&#192; propos</i>
#------------------------------

#@gimp_fr G'MIC pour GIMP : gimp_logo_big_fr, gimp_logo_fr
#@gimp_fr : note = note{"
#@gimp_fr : <span foreground="purple">( <b>G</b>REYC's <b>M</b>agic <b>I</b>mage <b>C</b>onverter )</span>\n\nvous est propos par"}
#@gimp_fr : note = link("David Tschumperl\303\251","http://www.greyc.ensicaen.fr/~dtschump")
#@gimp_fr : note = link{"( Equipe IMAGE / Laboratoire GREYC - CNRS UMR 6072 )","http://www.greyc.ensicaen.fr/EquipeImage"}
#@gimp_fr : note = note{"
#@gimp_fr : Ce greffon est bas&#233; sur nos biblioth&#232;ques libres <b>G'MIC</b> et <b>CImg</b> (C++ Template Image Processing Library),
#@gimp_fr : disponibles aux adresses :"}
#@gimp_fr : note = link("http://gmic.sourceforge.net/")
#@gimp_fr : note = note{"et"}
#@gimp_fr : note = link("http://cimg.sourceforge.net/")
#@gimp_fr : note = note{"\n
#@gimp_fr : Si vous appr&#233;ciez <b>G'MIC</b>, vous pouvez nous le faire savoir en nous envoyant une jolie carte
#@gimp_fr : postale de votre ville ou r&#233;gion, &#224; l'adresse :\n\n
#@gimp_fr : <small><tt>David Tschumperl&#233;,\n Laboratoire GREYC (CNRS UMR 6072), Equipe Image,\n
#@gimp_fr :  6 Bd du Mar&#233;chal Juin,\n 14050 Caen Cedex / France.</tt></small>\n\n
#@gimp_fr : Envoyer une carte postale vous fera rentrer <i>de facto</i> dans le <i>Friends Hall of Fame</i> :) !
#@gimp_fr : "}
gimp_logo_fr :
  -gimp_logo "\"Greffon pour GIMP\""
gimp_logo_big_fr :
  -gimp_logo_fr -quantize 8 -resize2x -frame 1,1,255

#@gimp_fr Cr&#233;ation de filtres : nop, gimp_logo_fr
#@gimp_fr : note = note{"
#@gimp_fr : <b>G'MIC</b> est un systme <b>ouvert</b> de traitement d'image. Il est ainsi possible
#@gimp_fr : d'ajouter vos <b>propres filtres personnaliss</b>  l'intrieur mme de ce greffon.\n\n
#@gimp_fr : Pour cela, il vous suffit de cr&#233;er un fichier <span foreground="purple" style="italic">.gmic</span>
#@gimp_fr : (ne pas oublier le premier point !) dans votre dossier <i>Home</i> (ou <i>Applications Data/</i> sous Windows).
#@gimp_fr : Ce fichier va tre lu &#224; chaque d&#233;marrage du greffon, ou lorsque le bouton <i>Actualiser</i>
#@gimp_fr : (sous le panneau central) sera cliqu&#233;. Ce fichier ascii va contenir les dclarations et les
#@gimp_fr : implmentations des filtres (crits en langage <b>G'MIC</b>) qui vont s'ajouter  la liste des filtres disponibles.\n\n
#@gimp_fr : Tous les filtres existants sont dj dfinis de cette faon. Les impl&#233;mentations actuelles sont visibles
#@gimp_fr : &#224; l'adresse :"}
#@gimp_fr : note = link("http://gmic.sourceforge.net/.gmic_def")
#@gimp_fr : note = note{"
#@gimp_fr : Ecrire un filtre en langage <b>G'MIC</b> n'est pas particulirement difficile (sans tre trivial),
#@gimp_fr : et ne n&#233;cessite souvent que quelques lignes.\n\n
#@gimp_fr : <span foreground="purple" underline="single">Exemple de fichier <i>.gmic</i> valide :</span>\n\n
#@gimp_fr : <tt>#@gimp My effect : my_effect, my_effect, Sigma = float(2,0,10)\n
#@gimp_fr : my_effect :\n     --blur $1 -n 0,255 -xor</tt>\n\n
#@gimp_fr : Vous &#234;tes bien s&#251;r encourag&#233;s &#224; partager vos propres filtres sur le forum pr&#233;vu &#224;
#@gimp_fr : cet effet, pour une inclusion ventuelle dans les prochaines versions de <b>G'MIC</b> :
#@gimp_fr : "}
#@gimp_fr : note = link("Participer au forum G'MIC","http://sourceforge.net/forum/forum.php?forum_id=923318")

#@gimp_fr Mise &#224; jour des filtres : nop, gimp_logo_fr
#@gimp_fr : note = note{"
#@gimp_fr : De par son architecture ouverte, <b>G'MIC</b> est capable de <b>mettre &#224; jour</b> sa liste
#@gimp_fr : de filtres. L'appui sur le bouton <i>Actualiser</i> (sous le panneau central)
#@gimp_fr : va permettre la connexion au serveur de mises &#224; jour, et le t&#233;l&#233;chargement
#@gimp_fr : des derni&#232;res d&#233;finitions de filtres. C'est la seule op&#233;ration r&#233;seau
#@gimp_fr : que nous avons autoris&#233;e dans <b>G'MIC</b>.\n\n
#@gimp_fr : Techniquement, cette proc&#233;dure cr&#233;&#233;/remplace le fichier
#@gimp_fr : <span foreground="purple" style="italic">.gmic_def.xxxx</span> dans votre r&#233;pertoire <i>Home</i>
#@gimp_fr : (ou <i>Application Data/</i> sous Windows),
#@gimp_fr : o&#249; <i>xxxx</i> sont les quatres chiffres du num&#233;ro de version du greffon <b>G'MIC</b>.
#@gimp_fr : En cas de probl&#232;me, vous pouvez donc toujours mettre &#224; jour vos filtres manuellement,
#@gimp_fr : en t&#233;l&#233;chargeant le fichier suivant :"}
#@gimp_fr : note = link("http://www.greyc.ensicaen.fr/~dtschump/gmic_def.xxxx")
#@gimp_fr : note = note{"
#@gimp_fr : Copiez juste ce fichier &#224; la bonne place, et renommez le en <span foreground="purple" style="italic">.gmic_def.xxxx</span>
#@gimp_fr : (n'oubliez pas le premier point, et remplacez les <i>xxxx</i> par le num&#233;ro de version de votre greffon <b>G'MIC</b>)
#@gimp_fr : et la proc&#233;dure de mise &#224; jour sera effectu&#233;e.
#@gimp_fr : Bien entendu, effacer ce fichier rinitialise l'ensemble des d&#233;finitions des filtres &#224; leurs &#233;tats initiaux.
#@gimp_fr : "}

#----------------------
# Catalan translations
#----------------------

#@gimp_ca <i>About</i>
#----------------------

#@gimp_ca G'MIC per al GIMP : gimp_logo_big_ca, gimp_logo_ca
#@gimp_ca : note = note{"
#@gimp_ca : <span foreground="purple">( <b>G</b>REYC's <b>M</b>agic <b>I</b>mage <b>C</b>onverter )</span>\n\n &#233;s una gentilesa de"}
#@gimp_ca : note = link("David Tschumperl\303\251","http://www.greyc.ensicaen.fr/~dtschump")
#@gimp_ca : note = link{"( IMAGE Team / GREYC Laboratory - CNRS UMR 6072 )","http://www.greyc.ensicaen.fr/EquipeImage"}
#@gimp_ca : note = note{"
#@gimp_ca : Aquest connector est&#224; basat en les biblioteques de codi obert <b>G'MIC</b> i <b>CImg</b> (C++ Template Image Processing Library),
#@gimp_ca : disponibles a :"}
#@gimp_ca : note = link("http://gmic.sourceforge.net/")
#@gimp_ca : note = note{"i"}
#@gimp_ca : note = link("http://cimg.sourceforge.net/")
#@gimp_ca : note = note{"\n
#@gimp_ca : Si t'agrada el <b>G'MIC</b>, pots enviar-nos una postal del lloc on vius, a :\n\n
#@gimp_ca : <small><tt>David Tschumperl&#233;,\n Laboratoire GREYC (CNRS UMR 6072), Equipe Image,\n
#@gimp_ca :  6 Bd du Mar&#233;chal Juin,\n 14050 Caen Cedex / France.</tt></small>\n\n
#@gimp_ca : Tot aquell que envi&#239; una postal apareixer&#224; al <i>Friends Hall of Fame</i> :) !
#@gimp_ca : "}
gimp_logo_ca :
  -gimp_logo "\"  per al GIMP\""
gimp_logo_big_ca :
  -gimp_logo_ca -quantize 8 -resize2x -frame 1,1,255

#@gimp_ca Filters design : nop, gimp_logo_ca
#@gimp_ca : note = note{"
#@gimp_ca : Si voleu podeu afegir els vostres <b>filtres d'usuari</b> al connector <b>G'MIC</b> :\n\n
#@gimp_ca : Per a fer-ho, cal que creeu un fitxer <span foreground="purple" style="italic">.gmic</span> (no oblideu el primer punt !)
#@gimp_ca : a la vostra <i>Carpeta d'inici</i> (o a la carpeta <i>Application Data</i> al Windows).
#@gimp_ca : El connector el llegir&#224; cada vegada que s'arranqui, o quan premeu el bot&#243; <i>Actualitzar els filtres</i>.
#@gimp_ca : Aquest fitxer ha de ser un arxiu de command del <b>G'MIC</b>, i ha de contindre les definicions de filtre
#@gimp_ca : que han d'apar&#232;ixer a la llista de filtres.
#@gimp_ca : Podeu veure un exemple d'un arxiu d'aquesta mena a :"}
#@gimp_ca : note = link("http://gmic.sourceforge.net/.gmic_def")
#@gimp_ca : note = note{"
#@gimp_ca : Escriure un nou filtre amb el llenguatge <b>G'MIC</b> no &#233;s trivial del tot (per&#242; tampoc una cosa inabastable), per&#242;
#@gimp_ca : normalment es pot fer en unes quantes l&#237;nies.\n\n
#@gimp_ca : <span foreground="purple" underline="single">Example d'un fitxer <i>.gmic</i> v&#224;lid :</span>\n\n
#@gimp_ca : <tt>#@gimp My effect : my_effect, my_effect, Sigma = float(2,0,10)\n
#@gimp_ca : my_effect :\n  --blur $1 -n 0,255 -xor</tt>\n\n
#@gimp_ca : Per cert, us encoratgem a que compartiu els vostres filtres personalitzats al f&#242;rum espec&#237;fic de <b>G'MIC</b> :
#@gimp_ca : "}
#@gimp_ca : note = link("Enlla\303\247a al f\303\262rum G'MIC","http://sourceforge.net/forum/forum.php?forum_id=923318")

#@gimp_ca Filters update : nop, gimp_logo_ca
#@gimp_ca : note = note{"
#@gimp_ca : El connector <b>G'MIC</b> &#233;s capa&#231; d'<b>actualitzar</b> la seva llista de definicions de filtres
#@gimp_ca : des d'Internet. Prement el bot&#243; <i>Actualitzar els filtres</i> al plaf&#243; de l'esquerra
#@gimp_ca : fa que <b>G'MIC</b> es connecti amb el servidor d'actualitzacions
#@gimp_ca : i que descarregui les darreres definicions de filtres disponibles.\n\n
#@gimp_ca : B&#224;sicament, aquest procediment crea un fitxer
#@gimp_ca : <span foreground="purple" style="italic">.gmic_def.xxxx</span> a la vostra <i>Carpeta d'inici</i>
#@gimp_ca : (o a la carpeta <i>Application Data</i> a Windows),
#@gimp_ca : on <i>xxxx</i> s&#243;n els quatre d&#237;gits de la versi&#243; del connector <b>G'MIC</b>.
#@gimp_ca : En cas que tingueu problemes, podeu actualitzar manualment els vostres filtres, baixant-vos el fitxer d'actualitzaci&#243; des de:"}
#@gimp_ca : note = link("http://www.greyc.ensicaen.fr/~dtschump/gmic_def.xxxx")
#@gimp_ca : note = note{"
#@gimp_ca : Llavors, nom&#233;s cal que copieu i canvieu el nom d'aquest fitxer com a <span foreground="purple" style="italic">.gmic_def.xxxx</span>
#@gimp_ca : (no oblideu el primer punt, i substitu&#239;u <i>xxxx</i> per el n&#250;mero de versi&#243; del vostre <b>G'MIC</b>)
#@gimp_ca : i ja est&#224;!
#@gimp_ca : Per cert, si esborreu aquest fitxer, tornareu a establir les definicions de filtres originals.
#@gimp_ca : "}

#----------------------
# Untranslated filters
#----------------------

#@gimp Release notes : nop, gimp_logo_en
#@gimp : note = note{"
#@gimp : - <b>2009/01/13</b> : version <i>1.3.0.0</i> (Initial).\n
#@gimp : - <b>2009/03/18</b> : version <i>1.3.1.0</i>.\n
#@gimp : - <b>2009/08/10</b> : version <i>1.3.2.0</i>.\n
#@gimp : - <span foreground="purple"><b>2009/10/10</b> : version <i>1.3.2.8</i> (Current).</span>\n
#@gimp : "}

#@gimp_en Contributors : nop, gimp_friends_en
#@gimp_en : note = note{"
#@gimp_en : We would like to thank all these people who contributed to <b>G'MIC</b> in one way or another.
#@gimp_en : A big hug to : \n\n
#@gimp_en : <b> -</b> <i>Claude Bulin</i> <small>(packaging)</small>
#@gimp_en : <b> -</b> <i>J&#233;rome Ferrari</i> <small>(testing)</small>
#@gimp_en : <b> -</b> <i>Jalal Fadili</i> <small>(compiling)</small>
#@gimp_en : <b> -</b> <i>Angelo Lama</i> <small>(testing)</small>
#@gimp_en : <b> -</b> <i>PhotoComiX</i> <small>(testing &amp; Italian translation)</small>
#@gimp_en : <b> -</b> <i>Gilmoth</i> <small>(Italian translation)</small>
#@gimp_en : <b> -</b> <i>Fran&#231;ois Collard</i> <small>(testing)</small>
#@gimp_en : <b> -</b> <i>St&#233;phane de la Linuxerie</i> <small>(design)</small>
#@gimp_en : <b> -</b> <i>Dani Sard&#224;</i> <small>(Catalan translation)</small>
#@gimp_en : <b> -</b> <i>The GIMP users at Flickr</i> <small>(testing and suggestions)</small>
#@gimp_en : <b> -</b>"}
gimp_friends :
  -rm -_heart80x73 -resize3x
  --*[-1] 70 --*[-2] 40 -*[-3] 255 -a c
  -flood 0,0,0,0,1,255 -blur_radial 1.5 -whirls 7,4,1,2.79 -patch 5,5,1 -n[-1] 64,255 -endpatch
  -text $1,16,30,24,0.7,0
  -gimp_unsharp 0,0.45,0,10,0,4,4,1,0,1
gimp_friends_en :
  -gimp_friends "\"Greetings to\n  all G'MIC\n  friends !\""
_heart80x73 :
  40,73,1,1,0 -ellipse 22,22,20,20,0,1,1 -polygon 3,7,37,42,72,42,27,1,1 --mirror x -a x

#@gimp Friends Hall of Fame : nop, gimp_friends_en
#@gimp : note = note{"\n<span foreground="purple" underline="single">Postcard senders :</span>"}
#@gimp : note = note{"    <b>-</b> <b>2</b> postcards received so far, you could be the 3rd sender ! :)"}
#@gimp : note = note{" We would like to say a big thank to :"}
#@gimp : link = link("[1] Jean-Michel Webbe - Guadeloupe/France","http://cimg.sourceforge.net/img/postcard15.jpg")
#@gimp : link = link("[2] Jaime - Barcelona/Spain","http://cimg.sourceforge.net/img/postcard14.jpg")
#@gimp : note = note{"\nMay the force be with you !"}


#@gimp _<b>Arrays &amp; frames</b>
#----------------------------------

#@gimp Regular array : gimp_array, gimp_array_preview
#@gimp : Number of tiles along X = int(2,1,10)
#@gimp : Number of tiles along Y = int(2,1,10)
#@gimp : X-offset = float(0,0,100)
#@gimp : Y-offset = float(0,0,100)
#@gimp : Mirroring = choice("None","X-axis","Y-axis","XY-axes")
#@gimp : Image size = _choice("Shrink", "Expand", "Repeat [Memory consuming !]")
gimp_array_preview :
  -gimp_array $1,$2,$3,$4,$5,0

gimp_array :
  -shift -$3%,-$4%,0,0,2
  -if {$5&1} -mirror x -endif -if {$5>1} -mirror y -endif
  -array $1,$2,$6

#@gimp Faded array : gimp_array_fade, gimp_array_fade_preview
#@gimp : Number of tiles along X = int(2,1,10)
#@gimp : Number of tiles along Y = int(2,1,10)
#@gimp : X-offset = float(0,0,100)
#@gimp : Y-offset = float(0,0,100)
#@gimp : Fading start = float(80,1,100)
#@gimp : Fading end = float(90,1,100)
#@gimp : Mirroring = choice("None","X-axis","Y-axis","XY-axes")
#@gimp : Image size = _choice("Shrink", "Expand", "Repeat [Memory consuming !]")
gimp_array_fade_preview :
  -gimp_array_fade $1,$2,$3,$4,$5,$6,$7,0

gimp_array_fade :
  -if {$7&1} -mirror x -endif -if {$7>1} -mirror y -endif
  -array_fade $1,$2,$5,$6,$8
  -shift -$3%,-$4%,0,0,2

#@gimp Mirrored array : gimp_array_mirror, gimp_array_mirror_preview
#@gimp : Number of iterations = int(1,1,10)
#@gimp : X-offset = float(0,0,100)
#@gimp : Y-offset = float(0,0,100)
#@gimp : Array mode = choice(2,"X-axis","Y-axis","XY-axes")
#@gimp : Mirroring = choice("None","X-axis","Y-axis","XY-axes")
#@gimp : Expand size = _bool(false)
gimp_array_mirror_preview :
  -gimp_array_mirror $1,$2,$3,$4,$5,0

gimp_array_mirror :
  -if {$5&1} -mirror x -endif -if {$5>1} -mirror y -endif
  -array_mirror $1,$4,$5
  -shift -$2%,-$3%,0,0,2

#@gimp Random array : array_random, array_random
#@gimp : Number of source tiles along X = int(5,1,20)
#@gimp : Number of source tiles along Y = int(5,1,20)
#@gimp : Number of destination tiles along X = int(7,1,20)
#@gimp : Number of destination tiles along Y = int(7,1,20)

#@gimp Color array : gimp_array_color, gimp_array_color
#@gimp : Number of tiles along X = int(5,1,20)
#@gimp : Number of tiles along Y = int(5,1,20)
#@gimp : Opacity = float(0.5,0,1)
gimp_array_color :
  -repeat @# -l[-1]
    $1,$2,1,3 -rand[-1] 0,255 -to_colormode[-1] @{-2,s} -r[-1] [-2] -*[-1] $3 -*[-2] {1-$3} -+[-2,-1]
  -endl -mv[-1] 0 -done

#@gimp Tiled rotation : gimp_rotate_tiles, gimp_rotate_tiles
#@gimp : Number of cells along X = int(5,1,80)
#@gimp : Number of cells along Y = int(5,1,80)
#@gimp : Rotation angle = float(15,0,360)
#@gimp : Opacity = float(1,0,1)
gimp_rotate_tiles :
  -to_rgba -rotate_tiles $3,$1,$2
  -if {$4<1} -repeat @# -s[-1] c -*[-1] $4 -a[-4--1] c -mv[-1] 0 -done -endif

#@gimp Tiled normalization : gimp_normalize_tiles, gimp_normalize_tiles
#@gimp : Number of cells along X = int(25,1,80)
#@gimp : Number of cells along Y = int(25,1,80)
#@gimp : Minimal value = float(0,0,255)
#@gimp : Maximal value = float(255,0,255)
gimp_normalize_tiles :
  -repeat @# -l[-1] -split_tiles $1,$2 -n $3,$4 -append_tiles $1,$2 -endl -mv[-1] 0 -done

#@gimp Tiled random shift : gimp_shift_tiles, gimp_shift_tiles
#@gimp : Number of tiles along X = int(10,1,30)
#@gimp : Number of tiles along Y = int(10,1,30)
#@gimp : Shift amplitude = float(10,0,100)
#@gimp : Opacity = float(1,0,1)
gimp_shift_tiles :
  -to_rgba -shift_tiles $1,$2,$3
  -if {$4<1} -repeat @# -s[-1] c -*[-1] $4 -a[-4--1] c -mv[-1] 0 -done -endif

#@gimp Image grid : gimp_grid, gimp_grid
#@gimp : Grid tile size along X = int(10,2,100)
#@gimp : Grid tile size along Y = int(10,2,100)
gimp_grid :
  -to_rgba -grid $1,$2

#@gimp Taquin puzzle : taquin, taquin
#@gimp : Number of X-subdivisions = int(7,1,20)
#@gimp : Number of Y-subdivisions = int(7,1,20)

#@gimp Random pattern : gimp_array_pattern, gimp_array_pattern_preview
#@gimp : Number of tiles along X = int(10,1,30)
#@gimp : Number of tiles along Y = int(10,1,30)
#@gimp : Density of tiles = float(80,0,100)
#@gimp : Angle of tiles = float(180,0,180)
#@gimp : Zoom of tiles = float(30,0,100)
#@gimp : Opacity = float(1,0,1)
#@gimp : Image size = _choice("Shrink", "Expand", "Repeat [Memory consuming !]")
gimp_array_pattern :
  -to_rgba -array_pattern $1,$2,$3,$4,$5,$6,0

gimp_array_pattern_preview :
  -to_rgba -array_pattern $1,$2,$3,$4,$5,$6,$7

#@gimp Regular frame : gimp_frame, gimp_frame
#@gimp : Width = int(10,0,100)
#@gimp : Height = int(10,0,100)
#@gimp : Color = color(255,255,255,0)
gimp_frame :
  -repeat @#
    ({@{-1,w}*$1/100},{@{-1,h}*$2/100}) -round[-1] 1
    -frame[-2] @-1,$3,$4,$5,$6 -rm[-1]
  -mv[-1] 0 -done

#@gimp Fuzzy frame : gimp_frame_fuzzy, gimp_frame_fuzzy
#@gimp : Width = int(10,0,99)
#@gimp : Height = int(10,0,99)
#@gimp : Fuzzyness = float(10,0,40)
#@gimp : Smoothness = float(1,0,5)
#@gimp : Color = color(255,255,255,0)
gimp_frame_fuzzy :
  -repeat @#
    ({@{-1,w}*$1/200},{@{-1,h}*$2/200}) -round[-1] 1
    -frame_fuzzy[-2] @-1,$3,$4,$5,$6,$7,$8 -rm[-1]
  -mv[-1] 0 -done

#@gimp Round frame : frame_round, frame_round
#@gimp : Sharpness = float(6,0.1,20)
#@gimp : Size = float(20,0,100)
#@gimp : Smoothness = float(0.1,0,5)
#@gimp : Color = color(255,255,255,0)


#@gimp _<b>Artistic</b>
#-----------------------


#@gimp Polaroid : gimp_polaroid, gimp_polaroid
#@gimp : Frame border size = int(10,1,400)
#@gimp : Bottom border size = int(20,1,400)
#@gimp : X-offset = float(0,-20,20)
#@gimp : Y-offset = float(0,-20,20)
#@gimp : Smoothness = float(3,0,5)
#@gimp : Image expansion = float(20,0,150)
#@gimp : Rotation angle = float(20,0,360)
gimp_polaroid :
  -polaroid $1,$2 -drop_shadow $3,$4,$5,$6 -rotate $7,1

#@gimp Old photograph : old_photo, old_photo

#@gimp Drop shadow : gimp_drop_shadow, gimp_drop_shadow
#@gimp : X-offset = float(3,-20,20)
#@gimp : Y-offset = float(3,-20,20)
#@gimp : Smoothness = float(1.8,0,5)
#@gimp : Image expansion = float(20,0,150)
#@gimp : Rotation angle = float(0,0,360)
gimp_drop_shadow :
  -drop_shadow $1,$2,$3,$4 -rotate $5,1

#@gimp Reflection : gimp_reflect, gimp_reflect
#@gimp : Height = float(50,0,100)
#@gimp : Attenuation = float(1,0.1,4)
#@gimp : Color = color(110,160,190,64)
#@gimp : Waves amplitude = float(0,0,100)
#@gimp : Waves smoothness = float(1.5,0,4)
#@gimp : X-angle = float(0,-10,10)
#@gimp : Y-angle = float(-3.30,-10,10)
#@gimp : Focale = float(7,0,10)
#@gimp : Zoom = float(1.5,1,5)
gimp_reflect :
  -to_rgba[-1] --lines[-1] {100-$1}%,100% -mirror[-1] y -water[-1] $7,$8
  -s[-1] c
  -f[-4] "(i*(255-$6)+$6*$3)/255"
  -f[-3] "(i*(255-$6)+$6*$4)/255"
  -f[-2] "(i*(255-$6)+$6*$5)/255" -a[-4--1] c
  -*[-1] '(h^$2-y^$2)/h^$2' -a[-2,-1] y
  100%,100%,100%,1,$11*$12*(x/w-0.5)
  100%,100%,100%,1,$11*$12*(y/h-0.5)
  100%,100%,100%,1,$10*(x/w-0.5)+$9*(y/h-0.5)+$11
  -/[-3] [-1] -+[-3] 0.5 -*[-3] @{-3,w}
  -/[-2,-1] -+[-1] 0.5 -*[-1] @{-1,h}
  -a[-2,-1] c -warp[-2] [-1],0,1,0 -rm[-1]

#@gimp Color ellipses : gimp_color_ellipses, gimp_color_ellipses
#@gimp : Number of ellipses = int(400,0,3000)
#@gimp : Maximum radius = float(16,0,100)
#@gimp : Opacity = float(0.1,0.01,0.5)
gimp_color_ellipses :
  -to_rgb -color_ellipses $1,$2,$3

#@gimp Cartoon : cartoon, cartoon
#@gimp : Smoothness = float(0.5,0,2)
#@gimp : Sharpening = float(200,0,400)
#@gimp : Edge threshold = float(40,1,120)
#@gimp : Edge thickness = float(0.1,0,1)
#@gimp : Color strength = float(1.5,0,3)
#@gimp : Color quantization = int(4,2,256)

#@gimp Pen drawing : gimp_pen_drawing, gimp_pen_drawing
#@gimp : Amplitude = float(100,0,500)
gimp_pen_drawing :
  -to_rgb -drawing $1

#@gimp Whirl drawing : draw_whirl, draw_whirl
#@gimp : Amplitude = float(20,0,100)

#@gimp Cubism : cubism, cubism
#@gimp : Iterations = int(300,1,2000)
#@gimp : Bloc size = float(10,0,40)
#@gimp : Maximum angle = float(90,0,360)
#@gimp : Opacity = float(0.7,0.01,1)
#@gimp : Smoothness = float(0,0,5)

#@gimp Kaleidoscope : gimp_kaleidoscope, gimp_kaleidoscope
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : X-offset = float(0,0,100)
#@gimp : Y-offset = float(0,0,100)
#@gimp : Radius cut = float(100,0,100)
#@gimp : Angle cut = float(10,0,100)
#@gimp : Borders conditions = choice(2,"Black","Nearest","Repeat")
gimp_kaleidoscope :
  -shift $3%,$4%,0,0,2 -kaleidoscope $1,$2,$5,$6,$7

#@gimp B&amp;W stencil : stencilbw, stencilbw
#@gimp : Edge threshold = float(30,0,150)
#@gimp : Smoothness = float(10,0,30)

#@gimp B&amp;W pencil : pencilbw, pencilbw
#@gimp : Pencil type = float(0.3,0,5)
#@gimp : Amplitude = float(60,0,200)

#@gimp B&amp;W dots : dotsbw, gimp_dotsbw_preview
gimp_dotsbw_preview :
  -r 300%,300%,1,3,3 -dotsbw

#@gimp Warhol : warhol, warhol
#@gimp : Number of tiles along X = int(3,1,10)
#@gimp : Number of tiles along Y = int(3,1,10)
#@gimp : Smoothness = float(2,0,10)
#@gimp : Color = float(40,0,60)

#@gimp Soft glow : glow, glow
#@gimp : Amplitude = float(1,0,8)

#@gimp Tetris effect : gimp_tetris, gimp_tetris
#@gimp : Scale = int(10,1,20)
gimp_tetris :
  -to_rgb -tetris $1


#@gimp _<b>Colors</b>
#---------------------


#@gimp RGB mixer : gimp_mix_rgb, gimp_mix_rgb
#@gimp : Red gain = float(1,0,4)
#@gimp : Red offset = float(0,-255,255)
#@gimp : Red smoothness = float(0,0,10)
#@gimp : Green gain = float(1,0,4)
#@gimp : Green offset = float(0,-255,255)
#@gimp : Green smoothness = float(0,0,10)
#@gimp : Blue gain = float(1,0,4)
#@gimp : Blue offset = float(0,-255,255)
#@gimp : Blue smoothness = float(0,0,10)
#@gimp : note = note()
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
gimp_start_mix :
  -if {$1==1} --norm[-1] -split_tones[-1] 3 -+[-2,-1] -blur[-2,-1] $2 -r[-2,-1] [-3] -*[-1] [-3] -mv[-3] @#
  -elif {$1==2} --norm[-1] -split_tones[-1] 3 -+[-3,-1] -blur[-2,-1] $2 -r[-2,-1] [-3] -*[-2] [-3] -mv[-3] @#
  -elif {$1==3} --norm[-1] -split_tones[-1] 3 -+[-3,-2] -blur[-2,-1] $2 -r[-2,-1] [-3] -*[-2] [-3] -mv[-3] @#
  -endif
gimp_end_mix :
  -if {$1==1} -*[-3,-1] -+[-2,-1]
  -elif {$1==2} -*[-2,-1] -+[-2,-1]
  -elif {$1==3} -*[-2,-1] -+[-2,-1]
  -endif

gimp_mix_rgb :
  -repeat @# -l[-1] -split_opacity -reverse -to_rgb[-1]
    -gimp_start_mix $10,$11
    --[-1] 128 -s[-1] c
    -*[-3] $1 -+[-3] $2 -blur[-3] $3%
    -*[-2] $4 -+[-2] $5 -blur[-2] $6%
    -*[-1] $7 -+[-1] $8 -blur[-1] $9%
    -a[-3--1] c -+[-1] 128 -c[-1] 0,255
    -gimp_end_mix $10
  -if {@#!=3} -reverse -a c -endif -endl -mv[-1] 0 -done

#@gimp YCbCr mixer : gimp_mix_ycbcr, gimp_mix_ycbcr
#@gimp : Luminance gain = float(1,0,4)
#@gimp : Luminance offset = float(0,-255,255)
#@gimp : Luminance smoothness = float(0,0,10)
#@gimp : Blue chroma gain = float(1,0,4)
#@gimp : Blue chroma offset = float(0,-255,255)
#@gimp : Blue chroma smoothness = float(0,0,10)
#@gimp : Red chroma gain = float(1,0,4)
#@gimp : Red chroma offset = float(0,-255,255)
#@gimp : Red chroma smoothness = float(0,0,10)
#@gimp : note = note()
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
gimp_mix_ycbcr :
  -repeat @# -l[-1] -split_opacity -reverse -to_rgb[-1]
    -gimp_start_mix $10,$11
    -rgb2ycbcr[-1] --[-1] 128 -s[-1] c
    -*[-3] $1 -+[-3] $2 -blur[-3] $3%
    -*[-2] $4 -+[-2] $5 -blur[-2] $6%
    -*[-1] $7 -+[-1] $8 -blur[-1] $9%
    -a[-3--1] c -+[-1] 128 -c[-1] 0,255 -ycbcr2rgb[-1]
    -gimp_end_mix $10
  -if {@#!=3} -reverse -a c -endif -endl -mv[-1] 0 -done

#@gimp HSV mixer : gimp_mix_hsv, gimp_mix_hsv
#@gimp : Hue gain = float(1,0,4)
#@gimp : Hue offset = float(0,-180,180)
#@gimp : Hue smoothness = float(0,0,10)
#@gimp : Saturation gain = float(1,0,4)
#@gimp : Saturation offset = float(0,-1,1)
#@gimp : Saturation smoothness = float(0,0,10)
#@gimp : Value gain = float(1,0,4)
#@gimp : Value offset = float(0,-1,1)
#@gimp : Value smoothness = float(0,0,10)
#@gimp : note = note()
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
gimp_mix_hsv :
  -repeat @# -l[-1] -split_opacity -reverse -to_rgb[-1]
    -gimp_start_mix $10,$11
    -rgb2hsv[-1] -s[-1] c --[-2,-1] 0.5
    -*[-3] $1 -+[-3] $2 -blur[-3] $3%
    -*[-2] $4 -+[-2] $5 -blur[-2] $6%
    -*[-1] $7 -+[-1] $8 -blur[-1] $9%
    -mod[-3] 360 -+[-2,-1] 0.5 -c[-2,-1] 0,1 -a[-3--1] c -hsv2rgb[-1]
    -gimp_end_mix $10
  -if {@#!=3} -reverse -a c -endif -endl -mv[-1] 0 -done

#@gimp Lab mixer : gimp_mix_lab, gimp_mix_lab
#@gimp : Lightness gain = float(1,0.5,1.5)
#@gimp : Lightness offset = float(0,-50,50)
#@gimp : Lightness smoothness = float(0,0,10)
#@gimp : A-color gain = float(1,0,4)
#@gimp : A-color offset = float(0,-20,20)
#@gimp : A-color smoothness = float(0,0,10)
#@gimp : B-color gain = float(1,0,4)
#@gimp : B-color offset = float(0,-20,20)
#@gimp : B-color smoothness = float(0,0,10)
#@gimp : note = note()
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
gimp_mix_lab :
  -repeat @# -l[-1] -split_opacity -reverse -to_rgb[-1]
    -gimp_start_mix $10,$11
    -rgb2lab[-1] -s[-1] c
    -*[-3] $1 -+[-3] $2 -blur[-3] $3%
    -*[-2] $4 -+[-2] $5 -blur[-2] $6%
    -*[-1] $7 -+[-1] $8 -blur[-1] $9%
    -a[-3--1] c -lab2rgb[-1]
    -gimp_end_mix $10
  -if {@#!=3} -reverse -a c -endif -endl -mv[-1] 0 -done

#@gimp CMYK mixer : gimp_mix_cmyk, gimp_mix_cmyk
#@gimp : Cyan gain = float(1,0,4)
#@gimp : Cyan offset = float(0,-255,255)
#@gimp : Cyan smoothness = float(0,0,10)
#@gimp : Magenta gain = float(1,0,4)
#@gimp : Magenta offset = float(0,-255,255)
#@gimp : Magenta smoothness = float(0,0,10)
#@gimp : Yellow gain = float(1,0,4)
#@gimp : Yellow offset = float(0,-255,255)
#@gimp : Yellow smoothness = float(0,0,10)
#@gimp : Key gain = float(1,0,4)
#@gimp : Key offset = float(0,-255,255)
#@gimp : Key smoothness = float(0,0,10)
#@gimp : note = note()
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
gimp_mix_cmyk :
  -repeat @# -l[-1] -split_opacity -reverse -to_rgb[-1]
    -gimp_start_mix $13,$14
    -rgb2cmyk[-1] -s[-1] c
    -*[-4] $1 -+[-4] $2 -blur[-4] $3%
    -*[-3] $4 -+[-3] $5 -blur[-3] $6%
    -*[-2] $7 -+[-2] $8 -blur[-2] $9%
    -*[-1] $10 -+[-1] $11 -blur[-1] $12%
    -a[-4--1] c -cmyk2rgb[-1]
    -gimp_end_mix $13
  -if {@#!=3} -reverse -a c -endif -endl -mv[-1] 0 -done

#@gimp Tones correction : gimp_tones_correction, gimp_tones_correction
#@gimp : Gamma correction = float(1,0.01,5)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Smoothness = float(0,0,10)
#@gimp : note = note()
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
gimp_tones_correction :
  -repeat @# -l[-1] -split_opacity -reverse -to_rgb[-1]
    -gimp_start_mix $5,$6
       -apply_gamma[-1] $1 --[-1] 128 -*[-1] $2 -+[-1] 128 -+[-1] $3 -blur[-1] $4% -c[-1] 0,255
    -gimp_end_mix $5
  -if {@#!=3} -reverse -a c -endif -endl -mv[-1] 0 -done

#@gimp Black &amp; White : gimp_blackandwhite, gimp_blackandwhite
#@gimp : Red level = float(0.299,0,1)
#@gimp : Red smoothness = float(0,0,10)
#@gimp : Green level = float(0.587,0,1)
#@gimp : Green smoothness = float(0,0,10)
#@gimp : Blue level = float(0.114,0,1)
#@gimp : Blue smoothness = float(0,0,10)
#@gimp : note = note()
#@gimp : Gamma correction = float(1,0.01,5)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : note = note()
#@gimp : Grain level (shadows) = float(0,0,200)
#@gimp : Grain level (midtones) = float(0,0,200)
#@gimp : Grain level (highlights) = float(0,0,200)
#@gimp : Grain tone fading = float(2,0,10)
#@gimp : Grain scale = float(0,0,3)
#@gimp : Grain type = choice("Gaussian","Uniform","Salt and pepper","Poisson")
#@gimp : note = note()
#@gimp : Local normalization = float(0,0,60)
#@gimp : Radius = int(16,1,512)
#@gimp : Normalization smoothness = float(4,0,10)
gimp_blackandwhite :
  -repeat @# -l[-1] -split_opacity -reverse -to_rgb[-1] -s[-1] c
    -*[-3] $1 -blur[-3] $2%
    -*[-2] $3 -blur[-2] $4%
    -*[-1] $5 -blur[-1] $6%
    -+[-3--1] -/[-1] {$1+$3+$5}
    -apply_gamma[-1] $7 --[-1] 128 -*[-1] $8 -+[-1] 128 -+[-1] $9 -c[-1] 0,255
    --split_tones[-1] 3 -a[-3--1] c -blur[-1] $11
    --f[-2] 1 -noise[-1] 100,$15 -blur[-1] $14 --n[-1] -$11,$11 --n[-2] -$12,$12 -n[-3] -$10,$10 -a[-3--1] c -*[-2,-1]
    -s[-1] c -+[-4--1] -c[-1] 0,255
  -if {@#!=1} -reverse -a c -endif -endl -mv[-1] 0 -done
  -normalize_local $16,$17,$18,2%,1,0,255

#@gimp Sepia : gimp_sepia, gimp_sepia
#@gimp : Gamma correction = float(1,0.01,5)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
gimp_sepia :
  -sepia -apply_gamma[-1] $1 -- 128 -* $2 -+ 128 -+ $3 -c 0,255

#@gimp B&amp;W dithering : gimp_ditheredbw, gimp_ditheredbw
#@gimp : Gamma correction = float(1,0.01,5)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Smoothness = float(0,0,10)
gimp_ditheredbw :
  -apply_gamma[-1] $1 -- 128 -* $2 -+ 128 -+ $3 -blur $4% -c 0,255 -ditheredbw

#@gimp Negative : gimp_negative, gimp_negative
#@gimp : Gamma correction = float(1,0.01,5)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Smoothness = float(0,0,10)
gimp_negative :
  -f 255-i -apply_gamma[-1] $1 -- 128 -* $2 -+ 128 -+ $3 -blur $4% -c 0,255

#@gimp Select color : gimp_select_color, gimp_select_color
#@gimp : Similarity space = choice(0,"RGB[A]","YCbCr","Red","Green","Blue","Opacity","Luminance","Blue & Red chrominances","Hue","Saturation")
#@gimp : Tolerance = float(20,0,100)
#@gimp : Selected color = color(255,255,255,255)
#@gimp : Invert selection = bool(0)
_gimp_select_color :
  -if {$1==1} -to_rgb -rgb2ycbcr -return -endif
  -if {$1==2} -to_rgb -rgb2hsv -repeat @# -s[-1] c -n[-3--1] 0,255 -a[-3--1] c -mv[-1] 0 -done -return -endif
  -if {$1==3} -to_rgb -channels 1 -return -endif
  -if {$1==4} -to_rgb -channels 2 -return -endif
  -if {$1==5} -to_rgba -channels 3 -return -endif
  -if {$1==6} -to_rgb -rgb2ycbcr -channels 0 -endif
  -if {$1==7} -to_rgb -rgb2ycbcr -channels 1,2 -endif
  -if {$1==8} -to_rgb -rgb2hsv -channels 0 -/ 180 -* 3.1415926 -sin -n 0,255 -endif
  -if {$1==9} -to_rgb -rgb2hsv -channels 1 -n 0,255 -endif

gimp_select_color :
  ($3^$4^$5^$6) -_gimp_select_color $1
  -select_color[0--1] $2%,@-1 -rm[-1]
  -if $7 -* -1 -+ 1 -endif
  -n 0,255

#@gimp Replace color : gimp_replace_color, gimp_replace_color
#@gimp : Tolerance = float(100,1,450)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Selected color = color(255,255,255,255)
#@gimp : Replace color  = color(0,0,0,0)
gimp_replace_color :
  -to_rgba -replace_color $1,$2%,${3*} -c 0,255

#@gimp User-defined : gimp_custom_transform, gimp_custom_transform
#@gimp : Red - Green - Blue - Alpha = text{"i"}
#@gimp : Red - Green - Blue = text{"i + 90*(x/w)*cos(i/10)"}
#@gimp : Red = text{"i"}
#@gimp : Green = text{"i"}
#@gimp : Blue = text{"i"}
#@gimp : Alpha = text{"i"}
#@gimp : Value normalization = choice("None","RGB","RGBA")
gimp_custom_transform :
  -to_rgba -repeat @#
    -f[-1] $1
    -s[-1] c -a[-4--2] c -f[-2] $2
    -s[-2] c -f[-4] $3 -f[-3] $4 -f[-2] $5 -f[-1] $6
    -if {$7==0} -a[-4--1] c -c[-1] 0,255
    -elif {$7==1} -a[-4--2] c -n[-2] 0,255 -c[-1] 0,255 -a[-2,-1] c
    -else -a[-4--1] c -n[-1] 0,255
    -endif
  -mv[-1] 0 -done

#@gimp Linear gradient : gimp_linear_gradient, gimp_linear_gradient
#@gimp : Starting color = color(0,0,0,255)
#@gimp : Ending color = color(255,255,255,255)
#@gimp : Angle = float(45,0,360)
#@gimp : Fade start = float(0,0,100)
#@gimp : Fade end = float(100,0,100)
gimp_linear_gradient :
  -v- -repeat @#
    (@{-1,w},@{-1,h}) -rm[-2]
    ($1^$2^$3^$4) ($5^$6^$7^$8) -r[-2,-1] @-3 -rm[-3]
    -fade_linear $9,$10,$11
  -mv[-1] 0 -done -v+

#@gimp Radial gradient : gimp_radial_gradient, gimp_radial_gradient
#@gimp : Starting color = color(0,0,0,255)
#@gimp : Ending color = color(255,255,255,255)
#@gimp : Fade start = float(0,0,100)
#@gimp : Fade end = float(100,0,100)
#@gimp : X-center = float(50,0,100)
#@gimp : Y-center = float(50,0,100)
gimp_radial_gradient :
  -v- -repeat @#
    (@{-1,w},@{-1,h}) -rm[-2]
    ($1^$2^$3^$4) ($5^$6^$7^$8) -r[-2,-1] @-3 -rm[-3]
    100%,100% -=[-1] 1,$11%,$12% -distance[-1] 1 -_fade $9,$10
  -mv[-1] 0 -done -v+

#@gimp Corner gradient : gimp_corner_gradient, gimp_corner_gradient
#@gimp : "Color 1 (up/left corner)         " = color(255,255,255,128)
#@gimp : "Color 2 (up/right corner)       " = color(255,0,0,255)
#@gimp : "Color 3 (bottom/left corner)  " = color(0,255,0,255)
#@gimp : "Color 4 (bottom/right corner)" = color(0,0,255,255)
gimp_corner_gradient :
  -v- -repeat @#
    (@{-1,w},@{-1,h}) -rm[-2]
    ($1,$5;$9,$13^$2,$6;$10,$14^$3,$7;$11,$15^$4,$8;$12,$16) -r[-1] @-2,1,4,3 -rm[-2]
  -mv[-1] 0 -done -v+

#@gimp _<b>Contours</b>
#----------------------


#@gimp Gradient norm : gimp_gradient_norm, gimp_gradient_norm
#@gimp : Smoothness = float(0,0,5)
#@gimp : Min threshold = float(0,0,100)
#@gimp : Max threshold = float(100,0,100)
#@gimp : Negative colors = bool(0)
gimp_gradient_norm :
  -blur $1% -gradient_norm
  -c $2%,$3%
  -if $4 -negative -endif
  -n 0,255

#@gimp Gradient as RGB : gimp_gradient2rgb, gimp_gradient2rgb
#@gimp : Smoothness = float(0,0,5)
#@gimp : Min threshold = float(0,0,100)
#@gimp : Max threshold = float(100,0,100)
#@gimp : Orientation only = bool(0)
#@gimp : Negative colors = bool(0)
gimp_gradient2rgb :
  -blur $1% -gradient2rgb $4
  -c $2%,$3%
  -if $5 -negative -endif
  -n 0,255

#@gimp Local orientation : gimp_local_orientation gimp_local_orientation
#@gimp : Smoothness = float(0,0,5)
#@gimp : Min threshold = float(0,0,100)
#@gimp : Max threshold = float(100,0,100)
#@gimp : Negative colors = bool(0)
gimp_local_orientation :
  -blur $1% -norm -gradient_orientation 2 -complex2polar -rm[0--1:2]
  -c $2%,$3%
  -if $4 -negative -endif
  -n 0,255

#@gimp Laplacian : gimp_laplacian, gimp_laplacian
#@gimp : Smoothness = float(0,0,5)
#@gimp : Min threshold = float(0,0,100)
#@gimp : Max threshold = float(100,0,100)
#@gimp : Absolute value = bool(0)
#@gimp : Negative colors = bool(0)
gimp_laplacian :
  -blur $1% -laplacian
  -if $4 -abs -endif
  -c $2%,$3%
  -if $5 -negative -endif
  -n 0,255

#@gimp Curvature : gimp_curvature, gimp_curvature
#@gimp : Smoothness = float(2,0,5)
#@gimp : Min threshold = float(0,0,100)
#@gimp : Max threshold = float(100,0,100)
#@gimp : Absolute value = bool(0)
#@gimp : Negative colors = bool(0)
gimp_curvature :
  -blur $1% -curvature
  -if $4 -abs -endif
  -c $2%,$3%
  -if $5 -negative -endif
  -n 0,255

#@gimp Edges : gimp_edges, gimp_edges
#@gimp : Smoothness = float(0,0,5)
#@gimp : Threshold = float(30,1,70)
#@gimp : Negative colors = bool(0)
gimp_edges :
  -to_rgb -blur $1% -edges $2
  -if $3 -negative -endif
  -n 0,255

#@gimp Isophotes : gimp_isophotes, gimp_isophotes
#@gimp : Number of levels = int(16,1,256)
#@gimp : Smoothness = float(0,0,5)
#@gimp : Filling = choice(0,"Transparent","Colors")
gimp_isophotes :
  -if $3
    -topographic_map $1,$2%
  -else
    -blur $2% -isophotes $1
  -endif

#@gimp Difference of gaussians : gimp_dog, gimp_dog
#@gimp : 1st Variance = float(1.4,0,5)
#@gimp : 2nd Variance = float(1.5,0,5)
#@gimp : Threshold = float(0,0,49)
#@gimp : Negative colors = bool(0)
gimp_dog :
  -dog $1%,$2%
  -c $3%,{100-$3}%
  -if $4 -negative -endif
  -n 0,255

#@gimp Morphological filter : gimp_morpho, gimp_morpho
#@gimp : Action = choice("Erosion","Dilation","Opening","Closing",
#@gimp : "Original - Erosion","Original - Dilation","Original - Opening","Original - Closing")
#@gimp : Size = int(5,2,60)
#@gimp : Invert colors = bool(false)
gimp_morpho :
  -if {$1==0} -erode $2
  -elif {$1==1} -dilate $2
  -elif {$1==2} -erode $2 -dilate $2
  -elif {$1==3} -dilate $2 -erode $2
  -elif {$1==4} -repeat @# --erode $2 --[-2,-1] -n[-1] 0,255 -mv[-1] 0 -done
  -elif {$1==5} -repeat @# --dilate $2 --[-2,-1] -n[-1] 0,255 -mv[-1] 0 -done
  -elif {$1==6} -repeat @# --erode $2 -dilate[-1] $2 --[-2,-1] -n[-1] 0,255 -mv[-1] 0 -done
  -else -repeat @# --dilate $2 -erode[-1] $2 --[-2,-1] -n[-1] 0,255 -mv[-1] 0 -done
  -endif
  -if $3 -negative -endif


#@gimp _<b>Deformations</b>
#--------------------------


#@gimp Water : water, water
#@gimp : Amplitude = float(30,0,300)
#@gimp : Smoothness = float(1.5,0,4)

#@gimp Wave : wave, wave
#@gimp : Amplitude = float(10,0,30)
#@gimp : Frequency = float(0.4,0,2)
#@gimp : X-center = float(50,0,100)
#@gimp : Y-center = float(50,0,100)

#@gimp Twirl : twirl, twirl
#@gimp : Amplitude = float(1,-5,5)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Borders conditions = choice(1,"Black","Nearest","Repeat")

#@gimp Flower : gimp_flower, gimp_flower
#@gimp : Amplitude = float(30,-100,100)
#@gimp : Number of petals = int(6,0,20)
#@gimp : Radius offset = float(0,0,100)
#@gimp : Angle = float(0,0,360)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Borders conditions = choice(2,"Black","Nearest","Repeat")
gimp_flower :
  -flower $1,$2,$3%,$4,$5,$6,$7

#@gimp Random : deform, deform
#@gimp : Amplitude = float(10,0,100)

#@gimp Fish-eye : fish_eye, fish_eye
#@gimp : X-center = float(50,0,100)
#@gimp : Y-center = float(50,0,100)
#@gimp : Radius = float(70,0,100)
#@gimp : Amplitude = float(1,0,2)

#@gimp Perspective : gimp_warp_perspective, gimp_warp_perspective
#@gimp : X-angle = float(1.73,-4,4)
#@gimp : Y-angle = float(0,-4,4)
#@gimp : Zoom = float(1,0.1,4)
#@gimp : X-center = float(50,0,100)
#@gimp : Y-center = float(50,0,100)
#@gimp : X-offset = float(0,0,100)
#@gimp : Y-offset = float(0,0,100)
#@gimp : Borders conditions = choice(2,"Black","Nearest","Repeat")
gimp_warp_perspective :
  -shift $6%,$7%,0,0,2 -warp_perspective $1,$2,$3,$4,$5,$8

#@gimp Euclidean &#60;-&#62; Polar : gimp_euclidean2polar, gimp_euclidean2polar
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Dilatation = float(1,0.1,10)
#@gimp : Borders conditions = choice(1,"Black","Nearest","Repeat")
#@gimp : Inverse transform = bool(0)
gimp_euclidean2polar :
  -if $5 -polar2euclidean $1,$2,$3,$4 -else -euclidean2polar $1,$2,$3,$4 -endif

#@gimp Cartesian transform : gimp_custom, gimp_custom_deformation
#@gimp : X-warping formula = text{"(w+h)/20*cos(y*20/h)"}
#@gimp : Y-warping formula = text{"(w+h)/20*sin(x*20/w)"}
#@gimp : Relative warping = bool(1)
#@gimp : Interpolation mode = choice(1,"Nearest neighbor","Linear")
#@gimp : Border conditions = choice(1,"Black","Nearest","Repeat")
gimp_custom_deformation :
   -repeat @#
    --norm[-1] [-1] -f[-2] $1 -f[-1] $2
    -a[-2,-1] c -warp[-2] [-1],$3,$4,$5,1 -rm[-1]
  -mv[-1] 0 -done

#@gimp Polar transform : gimp_transform_polar, gimp_transform_polar
#@gimp : Preset = choice("Custom transform","Inverse radius","Swap radius/angle")
#@gimp : X-center = float(50,0,100)
#@gimp : Y-center = float(50,0,100)
#@gimp : Radius formula = text{"r+R/10*cos(a*5)"}
#@gimp : Angle formula = text{"a"}
#@gimp : Border conditions = choice(1,"Black","Nearest","Repeat")
gimp_transform_polar :
  -if {$1==0}
    -transform_polar \"$4\",\"$5\",$2,$3,$6
  -elif {$1==1}
    -transform_polar R-r,a,$2,$3,$6
  -else
    -transform_polar a*R/(2*pi),r*2*pi/R,$2,$3,$6
  -endif

#@gimp _<b>Degradations</b>
#---------------------------


#@gimp Additive noise : gimp_noise, gimp_noise
#@gimp : Amplitude = float(10,0,200)
#@gimp : Noise type = choice("Gaussian","Uniform","Salt and pepper","Poisson")
#@gimp : Value range = choice("Cut","Normalize")
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
gimp_noise :
  -apply "\"-noise $1,$2\"",$4
  -if $3 -n 0,255 -else -c 0,255 -endif

#@gimp Spread noise : gimp_spread, gimp_spread
#@gimp : Variations along X = float(4,0,20)
#@gimp : Variations along Y = float(4,0,20)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
gimp_spread :
  -apply "\"-spread $1,$2\"",$3

#@gimp Random shade stripes : gimp_shade_stripes, gimp_shade_stripes
#@gimp : Frequency = float(30,1,100)
#@gimp : Stripes orientation = choice(1,"Horizontal","Vertical")
#@gimp : Darkness = float(0.8,0,3)
#@gimp : Lightness = float(1.3,0,3)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
gimp_shade_stripes :
  -apply "\"-shade_stripes $1,$2,$3,$4\"",$5

#@gimp Old-movie stripes : gimp_stripes_y, gimp_stripes_y
#@gimp : Frequency = float(10,0,100)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
gimp_stripes_y :
  -apply "\"-stripes_y $1\"",$2

#@gimp Damp patch : gimp_damp_patch, gimp_damp_patch
#@gimp : Opacity = float(0.7,0,1)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
gimp_damp_patch :
  -apply "\"-damp_patch $1\"",$2

#@gimp Light patch : gimp_light_patch, gimp_light_patch
#@gimp : Density = int(5,2,30)
#@gimp : Darkness = float(0.7,0,1)
#@gimp : Lightness = float(2.5,1,4)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
gimp_light_patch :
  -apply "\"-light_patch $1,$2,$3\"",$4

#@gimp Linear blur : gimp_blur_linear, gimp_blur_linear
#@gimp : Tangent amplitude = float(0.07,0.01,0.5)
#@gimp : Orthogonal amplitude = float(0.01,0.005,0.1)
#@gimp : Angle = float(0,0,180)
#@gimp : Border conditions = choice(1,"Black","Nearest")
#@gimp : Value normalization = bool(1)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
gimp_blur_linear :
  -apply "\"-blur_linear $1,$2,$3,$4\"",$6
  -if $5 -n 0,255 -endif

#@gimp Radial blur : gimp_blur_radial, gimp_blur_radial
#@gimp : Amplitude = float(3,0,20)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Value normalization = bool(1)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
gimp_blur_radial :
  -apply "\"-blur_radial $1%,$2,$3\"",$5
  -if $4 -n 0,255 -endif

#@gimp Angular blur : gimp_blur_angular, gimp_blur_angular
#@gimp : Amplitude = float(2,0,10)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Value normalization = bool(1)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
gimp_blur_angular :
  -apply "\"-blur_angular $1%,$2,$3\"",$5
  -if $4 -n 0,255 -endif

#@gimp RGB Bayer mask : rgb2bayer, rgb2bayer
#@gimp : Starting pattern = choice(0,"Red-Green","Blue-Green","Green-Red","Green-Blue")
#@gimp : Keep colors = bool(1)


#@gimp _<b>Enhancement</b>
#--------------------------


#@gimp Anisotropic smoothing : gimp_anisotropic_smoothing, gimp_anisotropic_smoothing
#@gimp : Amplitude = float(60,0,1000)
#@gimp : Sharpness = float(0.7,0,2)
#@gimp : Anisotropy = float(0.3,0,1)
#@gimp : Gradient smoothness = float(0.6,0,10)
#@gimp : Tensor smoothness = float(1.1,0,10)
#@gimp : Spatial precision = float(0.8,0.1,2)
#@gimp : Angular precision = float(30,1,180)
#@gimp : Value precision = float(2,0.1,5)
#@gimp : Interpolation type = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gimp : Fast approximation = bool(1)
#@gimp : Number of iterations = int(1,1,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
#@gimp : Tile subdivisions = int(1,1,10)
gimp_anisotropic_smoothing :
  -repeat @# -l[@{>,-1}]
    -split_tiles $13,$13
    -apply "\"-repeat $11 -smooth $1,$2,$3,$4,$5,$6,$7,$8,$9,$10 -done\"",$12
    -append_tiles $13,$13
  -endl -done -c 0,255

#@gimp Patch-based smoothing : gimp_patch_smoothing, gimp_patch_smoothing
#@gimp : Spatial variance = float(10,0.1,200)
#@gimp : Patch variance = float(10,0.1,200)
#@gimp : Patch size = int(3,2,21)
#@gimp : Lookup size = int(5,2,21)
#@gimp : Patch smoothness = float(0,0,4)
#@gimp : Fast approximation = bool(1)
#@gimp : Number of iterations = int(1,1,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
gimp_patch_smoothing :
  -apply "\"-repeat $7 -denoise $1,$2,$3,$4,$5,$6 -done\"",$8 -c 0,255

#@gimp Edge-preserving flow : gimp_edgepreserving_smoothing, gimp_edgepreserving_smoothing
#@gimp : Sharpness = float(0.7,0,2)
#@gimp : Anisotropy = float(0.3,0,1)
#@gimp : Gradient smoothness = float(0.6,0,10)
#@gimp : Tensor smoothness = float(1.1,0,10)
#@gimp : Time step = float(15,5,50)
#@gimp : Number of iterations = int(8,1,100)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
gimp_edgepreserving_smoothing :
  -apply "\"-smooth $6,$1,$2,$3,$4,$5,0\"",$7 -c 0,255

#@gimp Mean-curvature flow : gimp_meancurvature_smoothing, gimp_meancurvature_smoothing
#@gimp : Time step = float(30,5,50)
#@gimp : Number of iterations = int(4,1,10)
#@gimp : Keep iterations as different layers = bool(false)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
gimp_meancurvature_smoothing :
  -apply "\"-meancurvature_flow $2,$1,$3\"",$4 -c 0,255

#@gimp Total-variation flow : gimp_tv_smoothing, gimp_tv_smoothing
#@gimp : Time step = float(30,5,100)
#@gimp : Number of iterations = int(10,1,40)
#@gimp : Keep iterations as different layers = bool(false)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
gimp_tv_smoothing :
  -apply "\"-tv_flow $2,$1,$3\"",$4 -c 0,255

#@gimp Bilateral filtering : gimp_bilateral, gimp_bilateral
#@gimp : Spatial variance = float(10,0,100)
#@gimp : Value variance = float(7,0,100)
#@gimp : Number of iterations = int(2,1,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
gimp_bilateral :
  -apply "\"-repeat $3 -bilateral $1,$2 -done\"",$4

#@gimp Unsharp mask : gimp_unsharp, gimp_unsharp
#@gimp : Sharpening type = choice(0,"Gaussian","Bilateral")
#@gimp : Spatial radius = float(0.5,0,10)
#@gimp : Bilateral radius = float(30,0,60)
#@gimp : Amount = float(3,0,10)
#@gimp : Threshold = float(0,0,20)
#@gimp : Darkness level = float(1,0,4)
#@gimp : Lightness level = float(1,0,4)
#@gimp : Number of iterations = int(1,1,10)
#@gimp : Negative effect = bool(0)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
#@gimp : note = note{"\n\n<small><b>Note : </b>
#@gimp : This filter is inspired by the original <i>Unsharp Mask</i> filter in GIMP, with additional parameters.
#@gimp : </small>"}
_gimp_unsharp :
  -repeat @# -repeat $8
    -if {$1==0} --blur[-1] $2% -else --bilateral[-1] $2%,$3 -endif
    --[-1] [-2] -*[-1] -$4
    --norm[-1] -t[-1] $5% -r[-1] [-2] -*[-2,-1]
    -if $9 -*[-1] -1 -endif
    --c[-1] 0,100% -c[-2] -100%,0 -*[-2] $6 -*[-1] $7 -+[-2,-1]
    -+[-2,-1] -c[-1] 0,255
  -done -mv[-1] 0 -done

gimp_unsharp :
  -apply "\"-_gimp_unsharp $1,$2,$3,$4,$5,$6,$7,$8,$9\"",$10

#@gimp Inverse diffusion : gimp_sharpen_inversediff, gimp_sharpen_inversediff
#@gimp : Amplitude = float(50,1,300)
#@gimp : Number of iterations = int(2,1,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
gimp_sharpen_inversediff :
  -apply "\"-repeat $2 -sharpen $1,0 -c 0,255 -done\"",$3

#@gimp Shock filters : gimp_sharpen_shock, gimp_sharpen_shock
#@gimp : Amplitude = float(150,1,400)
#@gimp : Edge threshold = float(0.1,0,0.7)
#@gimp : Gradient smoothness = float(0.8,0,10)
#@gimp : Tensor smoothness = float(1.1,0,10)
#@gimp : Number of iterations = int(1,1,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
gimp_sharpen_shock :
  -apply "\"-repeat $5 -sharpen $1,1,$2,$3,$4 -c 0,255 -done\"",$6

#@gimp Local normalization : gimp_normalize_local, gimp_normalize_local
#@gimp : Amplitude = float(3,0,60)
#@gimp : Radius = int(16,1,512)
#@gimp : Neighborhood smoothness = float(4,0,10)
#@gimp : Average smoothness = float(2,0,10)
#@gimp : Constraint values = bool(1)
#@gimp : Channel(s) = choice(3,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
gimp_normalize_local :
  -apply "\"-normalize_local $1,$2,$3%,$4%,$5,0,255\"",$6 -c 0,255

#@gimp Region inpainting : gimp_inpaint, gimp_inpaint_preview
#@gimp : Use smooth inpaint = bool(true)
#@gimp : Number of global iterations = int(10,1,30)
#@gimp : Number of local iterations = int(10,1,30)
#@gimp : Time step = float(20,5,50)
#@gimp : Gradient smoothness = float(0.7,0,5)
#@gimp : Tensor smoothness = float(1.2,0,5)
#@gimp : note = note("<small><b>Note :</b>
#@gimp : This filter tries to reconstruct the content of image regions.
#@gimp : The inpainted region is defined as a white area in the top layer.
#@gimp : </small>")
gimp_inpaint :
  -if {@#==1} -return -endif
  -if $1 -inpaint_flow $2,$3,$4,-$5,-$6 -c 0,255 -else -inpaint[1--1] [0] -endif
  -to_rgba[0] -f[0] 0

gimp_inpaint_preview :
  -if {@#==1} -return -endif
  -gimp_inpaint $* -rm[0]

#@gimp Deinterlace : deinterlace, gimp_deinterlace
#@gimp : Algorithm = choice("Standard","Motion-compensated")
gimp_deinterlace :
  -deinterlace 0 -skip $*

#@gimp Red-Eye attenuation : red_eye, red_eye
#@gimp : Detection threshold = float(75,0,100)
#@gimp : Detection smoothness = float(3.5,0,20)
#@gimp : Attenuation factor = float(0.1,0,1)

#@gimp Scale2x algorithm : gimp_scalenx, gimp_scalenx_preview
#@gimp : Scaling factor = choice("x 2","x 3","x 4","x 6","x 8","x 9","x 12","x 16","x 18","x 27")
#@gimp : note = note{"\n<small><b>Note : </b>
#@gimp : This filter re-implements the scaling algorithm described at :
#@gimp : </small>"}
#@gimp : note = link("http://scale2x.sourceforge.net")
#@gimp : note = note{"<small>
#@gimp : This filter is useful for resizing images that have very few colors
#@gimp : (e.g. indexed images). It is generally useless for true colors images.
#@gimp : </small>"}
gimp_scalenx :
  -if {$1==0} -resize2x
  -elif {$1==1} -resize3x
  -elif {$1==2} -resize2x -resize2x
  -elif {$1==3} -resize3x -resize2x
  -elif {$1==4} -resize2x -resize2x -resize2x
  -elif {$1==5} -resize3x -resize3x
  -elif {$1==6} -resize3x -resize2x -resize2x
  -elif {$1==7} -resize2x -resize2x -resize2x -resize2x
  -elif {$1==8} -resize3x -resize3x -resize2x
  -elif {$1==9} -resize3x -resize3x -resize3x
  -endif

gimp_scalenx_preview :
  -crop 40%,40%,60%,60% -gimp_scalenx $1


#@gimp _<b>Layers</b>
#---------------------


#@gimp Average : compose_average, compose_average
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Filter input</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Multiply : compose_multiply, compose_multiply
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Filter input</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Screen : compose_screen, compose_screen
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Filter input</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Darken : compose_darken, compose_darken
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Filter input</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Lighten : compose_lighten, compose_lighten
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Filter input</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Difference : compose_difference, compose_difference
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Filter input</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Negation : compose_negation, compose_negation
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Filter input</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Exclusion : compose_exclusion, compose_exclusion
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Filter input</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Overlay : compose_overlay, compose_overlay
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Filter input</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Hard light : compose_hardlight, compose_hardlight
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Filter input</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Soft light : compose_softlight, compose_softlight
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Filter input</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Dodge : compose_dodge, compose_dodge
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Filter input</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Color burn : compose_colorburn, compose_colorburn
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Filter input</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Reflect : compose_reflect, compose_reflect
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Filter input</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Freeze : compose_freeze, compose_freeze
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Filter input</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Stamp : compose_stamp, compose_stamp
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Filter input</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Interpolation : compose_interpolation, compose_interpolation
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Filter input</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp XOR : compose_xor, compose_xor
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Filter input</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Edges merging : compose_edges, compose_edges
#@gimp : Smoothness = float(0.8,0,5)
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Filter input</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Frequency merging : gimp_compose_freq, gimp_compose_freq
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Filter input</i> option to handle multiple input layers.
#@gimp : </small>"}
gimp_compose_freq :
  -v- -repeat {@#/2}
    --[-1] 128 -*[-1] 2 -+[-2,-1] -c[-1] 0,255
  -mv[-1] 0 -done -v+

#@gimp Frequency splitting : gimp_split_freq, gimp_split_freq_preview
#@gimp : Smoothness = float(3,0,20)
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter splits an image layer into two layers, one containing the low frequencies (colors), the other with the high frequencies (contours). You can thus process each layer separatly, then recompose them with the previous <b>Frequency merging</b> filter.
#@gimp : </small>"}
gimp_split_freq_preview :
  -gimp_split_freq $1 -a x

gimp_split_freq :
  -v- -repeat @#
    --blur[-1] $1 --[-2] [-1] -/[-2] 2 -+[-2] 128 -reverse[-2,-1]
  -mv[-2,-1] 0 -done -v+

#@gimp Layers alignment : gimp_align_layers, gimp_align_layers_preview
#@gimp : Alignment type = choice(0,"Rigid","Non-rigid")
#@gimp : Smoothness = float(0.7,0,1)
#@gimp : Number of scales = choice(0,"Auto","1","2","3","4","5","6","7","8")
gimp_align_layers :
  -remove_opacity
  -if $1 -register_nonrigid $2,0.1,$3
  -else ($2) -*[-1] 3 -register_rigid[0--2] @-1 -rm[-1]
  -endif

gimp_align_layers_preview :
  -gimp_align_layers $1,$2,0 -compose_edges 0.1

#@gimp Layers morphing : gimp_morph, gimp_no_preview
#@gimp : Number of intra-frames = int(10,2,100)
#@gimp : Smoothness = float(0.2,0,2)
#@gimp : Precision = float(0.1,0,2)
gimp_morph :
  -to_rgb -morph $1,$2,$3

#@gimp Tiles to layers : split_tiles, gimp_split_tiles
#@gimp : Number of tiles along X = int(3,1,100)
#@gimp : Number of tiles along Y = int(3,1,100)
#@gimp : Homogeneous tiles = _bool(false)
gimp_split_tiles :
  -split_tiles $1,$2,$3 -k[50%]

#@gimp Layers to tiles : append_tiles, gimp_append_tiles_preview
#@gimp : Number of tiles along X = int(3,1,100)
#@gimp : Number of tiles along Y = int(3,1,100)
gimp_append_tiles_preview :
  -frame 1,1,0,0,0,255 -append_tiles $1,$2


#@gimp _<b>Patterns</b>
#-----------------------


#@gimp Random puzzle : gimp_puzzle, gimp_puzzle
#@gimp : Scale = float(10,1,20)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
gimp_puzzle :
  -apply "\"-puzzle $1\"",$2

#@gimp Mosaic pattern : gimp_mosaic, gimp_mosaic
#@gimp : Density = float(1,0.1,10)
#@gimp : Amplitude = float(-80,-255,255)
#@gimp : Relief = bool(true)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
gimp_mosaic :
  -apply "\"-mosaic $1,$2,$3\"",$4

#@gimp Whirls texture : gimp_whirls, gimp_whirls
#@gimp : Density = int(7,3,20)
#@gimp : Smoothness = float(2,0,10)
#@gimp : Darkness = float(0.2,0,1)
#@gimp : Lightness = float(1.8,1,3)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
gimp_whirls :
  -apply "\"-whirls $1,$2,$3,$4\"",$5

#@gimp Paper texture : gimp_paper_texture, gimp_paper_texture
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
gimp_paper_texture :
  -apply "\"-paper_texture\"",$1

#@gimp Hearts : gimp_hearts, gimp_hearts
#@gimp : Density = float(10,0,100)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
gimp_hearts :
  -apply "\"-hearts $1\"",$2

#@gimp Sponge effect : gimp_sponge, gimp_sponge
#@gimp : Sponge size = int(13,3,21)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
gimp_sponge :
  -apply "\"-sponge $1\"",$2

#@gimp Canvas effect : gimp_canvas, gimp_canvas
#@gimp : note = note{"<b>First direction :</b>"}
#@gimp : Amplitude = float(70,0,300)
#@gimp : Angle = float(45,0,180)
#@gimp : Sharpening = float(400,0,2000)
#@gimp : note = note{"\n<b>Second direction : </b>"}
#@gimp : Activate second direction = bool(true)
#@gimp : Amplitude = float(70,0,300)
#@gimp : Angle = float(135,0,180)
#@gimp : Sharpening = float(400,0,2000)
gimp_canvas :
  -if $4
  ({cos($2*pi/180)}^{sin($2*pi/180)}) -to_tensors[-1] -r[-1] [-2],[-2] --smooth[-2] [-1],$1 -rm[-2] -sharpen[-1] $3 -c[-1] 0,255
  ({cos($6*pi/180)}^{sin($6*pi/180)}) -to_tensors[-1] -r[-1] [-2],[-2] -smooth[-3] [-1],$5 -rm[-1] -sharpen[-2] $7 -c[-2] 0,255 -+[-2,-1] -/[-1] 2
  -else
  ({cos($2*pi/180)}^{sin($2*pi/180)}) -to_tensors[-1] -r[-1] [-2],[-2] -smooth[-2] [-1],$1 -rm[-1] -sharpen[-1] $3 -c[-1] 0,255
  -endif

#@gimp _<b>Presets</b>
#----------------------


#@gimp PhotoComiX smoothing : gimp_anisotropic_smoothing, gimp_anisotropic_smoothing
#@gimp : Amplitude = float(60,0,1000)
#@gimp : Edge preservation = float(0.16,0,2)
#@gimp : Anisotropy = float(0.63,0,1)
#@gimp : Gradient smoothness = float(0.6,0,10)
#@gimp : Tensor smoothness = float(2.35,0,10)
#@gimp : Spatial precision = float(0.8,0.1,2)
#@gimp : Angular precision = float(30,1,180)
#@gimp : Value precision = float(2,0.1,5)
#@gimp : Interpolation type = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gimp : Fast gaussian approximation = bool(1)
#@gimp : Number of iterations = int(1,1,10)
#@gimp : Channel(s) = choice("RGB","Luminance","Blue & Red chrominances","Blue chrominance","Red chrominance")
#@gimp : Tile subdivisions = int(1,1,10)
#@gimp : note = note{"\n<small><b>Note : </b>This set of anisotropic smoothing parameters has been suggested by PhotoComiX.</small>"}

#@gimp Thin brush smoothing : gimp_anisotropic_smoothing, gimp_anisotropic_smoothing
#@gimp : Amplitude = float(60,0,1000)
#@gimp : Edge preservation = float(0.9,0,2)
#@gimp : Anisotropy = float(0.64,0,1)
#@gimp : Gradient smoothness = float(3.1,0,10)
#@gimp : Tensor smoothness = float(1.10,0,10)
#@gimp : Spatial precision = float(0.8,0.1,2)
#@gimp : Angular precision = float(30,1,180)
#@gimp : Value precision = float(2,0.1,5)
#@gimp : Interpolation type = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gimp : Fast gaussian approximation = bool(1)
#@gimp : Number of iterations = int(1,1,10)
#@gimp : Channel(s) = choice("RGB","Luminance","Blue & Red chrominances","Blue chrominance","Red chrominance")
#@gimp : Tile subdivisions = int(1,1,10)
#@gimp : note = note{"\n<small><b>Note : </b>This set of anisotropic smoothing parameters has been suggested by PhotoComiX.</small>"}


#@gimp _<b>Rendering</b>
#------------------------


#@gimp 3D elevation [static] : gimp_elevation, gimp_elevation_preview
#@gimp : Rendering width = int(512,8,1024)
#@gimp : Rendering height = int(512,8,1024)
#@gimp : Value scale = float(0.05,-0.2,0.2)
#@gimp : Map smoothness = float(1,0,10)
#@gimp : X-angle = float(50,-90,90)
#@gimp : Y-angle = float(0,0,360)
#@gimp : Zoom = float(1,0.1,4)
#@gimp : Rendering type = choice(4,"Points","Lines","Flat","Flat shaded","Gouraud","Phong")
#@gimp : Opacity = float(1,0,1)
#@gimp : Focale = float(500,100,800)
#@gimp : note = note{"<small><b>Note :</b>
#@gimp : Use two input layers to define an elevation map that is different from
#@gimp : the image itself.
#@gimp : </small>"}
gimp_elevation :
  -if {@#==0} -q
  -elif {@#==1} --norm
  -else -k[0,1] -reverse
  -endif
  -to_rgb[0] -norm[1] -blur[1] $4 -*[1] $3 -r $1,$2,1,100%,3 -elevation3d[0] [1] -rm[1]
  -c3d -rot3d 0,0,1,$6 -rot3d 1,0,0,$5 -*3d $7 -m3d $8 -f3d $10
  $1,$2,1,4,-1 -object3d[-1] [0],50%,50%,0,$9 -rm[0]
  -s c -t[-1] 0 -*[-1] 255 -a c

gimp_elevation_preview :
  -if {@#==0} -q -endif
  -gimp_elevation @{-1,w},@{-1,h},$3,$4,$5,$6,$7,$8,$9,$10

#@gimp 3D elevation [animated] : gimp_elevation_anim, gimp_elevation_anim_preview
#@gimp : Rendering width = int(512,8,1024)
#@gimp : Rendering height = int(512,8,1024)
#@gimp : Value scale = float(0.05,-0.2,0.2)
#@gimp : Map smoothness = float(1,0,10)
#@gimp : X-angle = float(50,-90,90)
#@gimp : Rotation step = float(5,1,90)
#@gimp : Zoom = float(1,0.1,4)
#@gimp : Rendering type = choice(4,"Points","Lines","Flat","Flat shaded","Gouraud","Phong")
#@gimp : Opacity = float(1,0,1)
#@gimp : Focale = float(500,100,800)
#@gimp : Number of frames = int(10,1,360)
#@gimp : note = note{"<small><b>Note :</b>
#@gimp : Use two input layers to define an elevation map that is different from
#@gimp : the image itself.
#@gimp : </small>"}
gimp_elevation_anim :
  -if {@#==0} -q
  -elif {@#==1} --norm
  -else -k[0,1] -reverse
  -endif
  -to_rgb[0] -norm[1] -blur[1] $4 -*[1] $3 -r $1,$2,1,100%,3 -elevation3d[0] [1] -rm[1]
  -c3d -*3d $7 -m3d $8 -f3d $10
  -repeat $11
    --rot3d[0] 1,0,0,$5
    $1,$2,1,4,-1 -object3d[-1] [-2],50%,50%,0,$9 -rm[-2]
    -s[-1] c -t[-1] 0 -*[-1] 255 -a[-4--1] c
    -rot3d[0] 0,0,1,$6
  -done -rm[0]

gimp_elevation_anim_preview :
  -if {@#==0} -q -endif
  -gimp_elevation_preview @{-1,w},@{-1,h},$3,$4,$5,0,$7,$8,$9,$10

#@gimp 3D image cube : gimp_imagecube3d, gimp_imagecube3d
#@gimp : Rendering width = int(512,1,1024)
#@gimp : Rendering height = int(512,1,1024)
#@gimp : Image resolution = int(128,1,512)
#@gimp : Cube size = float(256,0,512)
#@gimp : X-angle = float(57,0,360)
#@gimp : Y-angle = float(41,0,360)
#@gimp : Z-angle = float(21,0,360)
gimp_imagecube3d :
  -repeat @# -l[@{>,-1}]
    -to_rgb -imagecube3d $3 -*3d $4 -rot3d 0,0,1,$7 -rot3d 0,1,0,$6 -rot3d 1,0,0,$5 -m3d 2 -db3d 0
    $1,$2,1,4,-1 -object3d[1] [0],50%,50% -k[1]
    -s[-1] c -t[-1] 0 -*[-1] 255 -a[-4--1] c
  -endl -done

#@gimp 3D random objects : gimp_random3d, gimp_random3d
#@gimp : Type of objects = choice("Cube","Cone","Cylinder","Sphere","Torus")
#@gimp : Number of objects = int(50,1,300)
#@gimp : Object size = float(3,1,20)
#@gimp : Z-range = float(100,0,300)
#@gimp : Rendering type = choice(3,"Points","Lines","Flat","Flat shaded","Gouraud","Phong")
#@gimp : Opacity = float(1,0,1)
_gimp_random3d0 : -box3d $1
_gimp_random3d1 : ($1) -/[-1] 2 -cone3d @-1,$1 -rm[-2]
_gimp_random3d2 : ($1) -/[-1] 2 -cylinder3d @-1,$1 -rm[-2]
_gimp_random3d3 : -sphere3d $1,2
_gimp_random3d4 : ($1) -/[-1] 3 -torus3d $1,@-1 -rm[-2]
gimp_random3d :
  -m3d $5 -db3d 0
  -repeat @# -l[@{>,-1}]
    -to_rgb (@{-1,w},@{-1,h},@{-1,d},@{-1,s}) -/[-1] 2 -repeat $2
    (@{1,0}) -+[-1] @{1,1} -*[-1] $3 -/[-1] 100 -_gimp_random3d$1 @-1 -rm[-2]
    -rot3d[-1] 1,1,0,{?(0,360)}
    ({?(-1,1)}) -*[-1] @{1,0} ({?(-1,1)}) -*[-1] @{1,1}
    -+3d[-3] @-2,@-1,{?(-$4,$4)} -rm[-2,-1]
    -col3d[-1] {?(255)},{?(255)},{?(255)} -done -+3d[2--1] -object3d[0] [-1],50%,50%,0,$6,0
    -k[0]
  -endl -done

#@gimp Mandelbrot / Julia sets : gimp_mandelbrot, gimp_mandelbrot_preview
#@gimp : X-center = float(0,-2,2)
#@gimp : Y-center = float(0,-2,2)
#@gimp : Zoom = float(0,0,100)
#@gimp : Number of iterations = int(128,1,512)
#@gimp : Fractal set = choice(Mandelbrot, Julia)
#@gimp : X-seed (Julia) = text("0.317")
#@gimp : Y-seed (Julia) = text("0.03")
#@gimp : Color 1 = color(0,0,255)
#@gimp : Color 2 = color(0,255,0)
#@gimp : Color 3 = color(255,0,0)
#@gimp : Color 4 = color(255,0,255)
gimp_mandelbrot :
  (0^0^0) ($8^$9^$10) ($11^$12^$13) ($14^$15^$16) ($17^$18^$19)
  -a[-4--1] x -r[-1] $4,1,1,3,3 -a[-2,-1] x -mv[-1] 0
  -repeat {@#-1}
    -p @{-1,w},@{-1,h} -rm[-1] @{*,-1} -pp[-1]
    -mandelbrot[-1] {$1-2/(1+$3)},{$2-2/(1+$3)},{$1+2/(1+$3)},{$2+2/(1+$3)},$4,$5,{if($5,$6,0)},{if($5,$7,0)}
    -map[-1] [0]
  -mv[-1] 1 -done -rm[0]

gimp_mandelbrot_preview :
  -gimp_mandelbrot $*
  -line 0,50%,100%,50%,0.5,255
  -line 50%,0,50%,100%,0.5,255

#@gimp _<b>Sequences</b>
#-----------------------

gimp_animate_preview : -skip ${4=1}
  -i[0] ({@{-1,w}/2},@{-1,h})
  -repeat {@#-1}
    -if $4 -s[-1] x,2 -else [-1] -endif
    -i $2 -i $3 -$1[-4] @-2 -$1[-3] @-1 -rm[-2,-1]
    -if {!$4} -columns[-2] 0,{@{-2,w}/2} -columns[-1] {@{-1,w}/2+1},100% -endif
    -r[-2,-1] @0,100%,100%,2 -a[-2,-1] x -drgba[-1]
    -line[-1] 50%,0,50%,100%,1,0,0,0,255
    34,11 -text[-1] "Start",2,0,6,1,1 --dilate[-1] 5 -to_colormode[-2] @{-3,s} -*[-2] 255 -image[-3] [-2],2,2,0,1,[-1] -rm[-2--1]
    21,12 -text[-1] "End",2,1,6,1,1 --dilate[-1] 5 -to_colormode[-2] @{-3,s} -*[-2] 255 -image[-3] [-2],{@{-3,w}-22},{@{-3,h}-13},0,1,[-1] -rm[-2--1]
  -mv[-1] 1 -done -rm[0]

#@gimp Polaroid : gimp_animate_polaroid, gimp_animate_polaroid_preview
#@gimp : Number of frames = _int(10,2,100)
#@gimp : Output frames = _bool(1)
#@gimp : Output files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Frame border size = int(10,1,400)
#@gimp : Bottom border size = int(20,1,400)
#@gimp : X-offset = float(0,-20,20)
#@gimp : Y-offset = float(0,-20,20)
#@gimp : Smoothness = float(3,0,5)
#@gimp : Image expansion = float(20,0,150)
#@gimp : Rotation angle = float(0,0,360)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Frame border size = int(10,1,400)
#@gimp : Bottom border size = int(20,1,400)
#@gimp : X-offset = float(0,-20,20)
#@gimp : Y-offset = float(0,-20,20)
#@gimp : Smoothness = float(3,0,5)
#@gimp : Image expansion = float(20,0,150)
#@gimp : Rotation angle = float(20,0,360)
_gimp_polaroid :
  -gimp_polaroid {round($1)},{round($2)},$3,$4,$5,$6,$7

gimp_animate_polaroid_preview :
  -gimp_animate_preview _gimp_polaroid,($5;$6;$7;$8;$9;$10;$11),($12;$13;$14;$15;$16;$17;$18),0

gimp_animate_polaroid :
  -animate _gimp_polaroid,($5;$6;$7;$8;$9;$10;$11),($12;$13;$14;$15;$16;$17;$18),$1,$2,$3,\"$4/gmic_polaroid\"

#@gimp Edges : gimp_animate_edges, gimp_animate_edges_preview
#@gimp : Number of frames = _int(10,2,100)
#@gimp : Output frames = _bool(1)
#@gimp : Output files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Smoothness = float(0,0,10)
#@gimp : Edge threshold = float(30,0,150)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Smoothness = float(0,0,10)
#@gimp : Edge threshold = float(60,0,150)
#@gimp : note = note{"\n<b>Global parameters :</b>"}
#@gimp : Negative colors = bool(0)
gimp_animate_edges_preview :
  -gimp_animate_preview gimp_edges,($5;$6;$9),($7;$8;$9)

gimp_animate_edges :
  -animate gimp_edges,($5;$6;$9),($7;$8;$9),$1,$2,$3,\"$4/gmic_edges\"

#@gimp Cartoon : gimp_animate_cartoon, gimp_animate_cartoon_preview
#@gimp : Number of frames = _int(10,2,100)
#@gimp : Output frames = _bool(1)
#@gimp : Output files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Smoothness = float(0.5,0,2)
#@gimp : Sharpening = float(200,0,400)
#@gimp : Edge threshold = float(40,1,120)
#@gimp : Edge thickness = float(0.1,0,1)
#@gimp : Color strength = float(1.5,0,3)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Smoothness = float(3,0,2)
#@gimp : Sharpening = float(200,0,400)
#@gimp : Edge threshold = float(40,1,120)
#@gimp : Edge thickness = float(0.1,0,1)
#@gimp : Color strength = float(1.5,0,3)
#@gimp : note = note{"\n<b>Global parameters :</b>"}
#@gimp : Color quantization = int(4,2,256)
gimp_animate_cartoon_preview :
  -gimp_animate_preview cartoon,($5;$6;$7;$8;$9;$15),($10;$11;$12;$13;$14;$15)

gimp_animate_cartoon :
  -animate cartoon,($5;$6;$7;$8;$9;$15),($10;$11;$12;$13;$14;$15),$1,$2,$3,\"$4/gmic_cartoon\"

#@gimp B&amp;W stencil : gimp_animate_stencilbw, gimp_animate_stencilbw_preview
#@gimp : Number of frames = _int(10,2,100)
#@gimp : Output frames = _bool(1)
#@gimp : Output files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Edge threshold = float(30,0,150)
#@gimp : Smoothness = float(10,0,30)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Edge threshold = float(30,0,150)
#@gimp : Smoothness = float(15,0,30)
gimp_animate_stencilbw_preview :
  -gimp_animate_preview stencilbw,($5;$6),($7;$8)

gimp_animate_stencilbw :
  -animate stencilbw,($5;$6),($7;$8),$1,$2,$3,\"$4/gmic_stencilbw\"

#@gimp B&amp;W pencil : gimp_animate_pencilbw, gimp_animate_pencilbw_preview
#@gimp : Number of frames = _int(10,2,100)
#@gimp : Output frames = _bool(1)
#@gimp : Output files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Pencil type = float(2.3,0,5)
#@gimp : Amplitude = float(100,0,200)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Pencil type = float(0.3,0,5)
#@gimp : Amplitude = float(60,0,200)
gimp_animate_pencilbw_preview :
  -gimp_animate_preview pencilbw,($5;$6),($7;$8)

gimp_animate_pencilbw :
  -animate pencilbw,($5;$6),($7;$8),$1,$2,$3,\"$4/gmic_pencilbw\"

#@gimp Soft glow : gimp_animate_glow, gimp_animate_glow_preview
#@gimp : Number of frames = _int(10,2,100)
#@gimp : Output as frames = _bool(1)
#@gimp : Output as files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Amplitude = float(0,0,8)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Amplitude = float(3,0,8)
gimp_animate_glow_preview :
  -gimp_animate_preview glow,($5),($6)

gimp_animate_glow :
  -animate glow,($5),($6),$1,$2,$3,\"$4/gmic_glow\"


#@gimp Morphological filter : gimp_animate_morpho, gimp_animate_morpho_preview
#@gimp : Number of frames = _int(10,2,100)
#@gimp : Output as frames = _bool(1)
#@gimp : Output as files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Size = int(150,2,200)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Size = int(1,1,200)
#@gimp : note = note{"\n<b>Global parameters :</b>"}
#@gimp : Action = choice("Erosion","Dilation","Opening","Closing",
#@gimp : "Original - Erosion","Original - Dilation","Original - Opening","Original - Closing")
#@gimp : Invert colors = bool(false)
gimp_animate_morpho_preview :
  -gimp_animate_preview gimp_morpho,($7;$5;$8),($7;$6;$8),0

_gimp_morpho :
  -gimp_morpho $1,{round($2)},$3

gimp_animate_morpho :
  -animate _gimp_morpho,($7;$5;$8),($7;$6;$8),$1,$2,$3,\"$4/gmic_morpho\"


#@gimp 3D image cube : gimp_animate_imagecube3d, gimp_animate_imagecube3d_preview
#@gimp : Number of frames = _int(10,2,100)
#@gimp : Output as frames = _bool(1)
#@gimp : Output as files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Cube size = float(128,0,512)
#@gimp : X-angle = float(57,0,1440)
#@gimp : Y-angle = float(41,0,1440)
#@gimp : Z-angle = float(21,0,1440)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Cube size = float(128,0,512)
#@gimp : X-angle = float(417,0,1440)
#@gimp : Y-angle = float(41,0,1440)
#@gimp : Z-angle = float(741,0,1440)
#@gimp : note = note{"\n<b>Global parameters :</b>"}
#@gimp : Rendering width = int(256,1,1024)
#@gimp : Rendering height = int(256,1,1024)
#@gimp : Image resolution = int(128,1,512)
gimp_animate_imagecube3d_preview :
  -k[50%] -gimp_animate_preview gimp_imagecube3d,($13;$14;$15;$5;$6;$7;$8),($13;$14;$15;$9;$10;$11;$12),0

gimp_animate_imagecube3d :
  -animate gimp_imagecube3d,($13;$14;$15;$5;$6;$7;$8),($13;$14;$15;$9;$10;$11;$12),$1,$2,$3,\"$4/gmic_cube3d\"

#@gimp Anisotropic smoothing : gimp_animate_anisotropic_smoothing, gimp_animate_anisotropic_smoothing_preview
#@gimp : Number of frames = _int(10,2,100)
#@gimp : Output as frames = _bool(1)
#@gimp : Output as files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Amplitude = float(60,0,1000)
#@gimp : Sharpness = float(0.7,0,2)
#@gimp : Anisotropy = float(0.3,0,1)
#@gimp : Gradient smoothness = float(0.6,0,10)
#@gimp : Tensor smoothness = float(1.1,0,10)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Amplitude = float(60,0,1000)
#@gimp : Sharpness = float(0.7,0,2)
#@gimp : Anisotropy = float(0.3,0,1)
#@gimp : Gradient smoothness = float(0.6,0,10)
#@gimp : Tensor smoothness = float(1.1,0,10)
#@gimp : note = note{"\n<b>Global parameters :</b>"}
#@gimp : Spatial precision = float(0.8,0.1,2)
#@gimp : Angular precision = float(30,1,180)
#@gimp : Value precision = float(2,0.1,5)
#@gimp : Interpolation type = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gimp : Fast approximation = bool(1)
#@gimp : Number of iterations = int(1,1,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
#@gimp : Tile subdivisions = int(1,1,10)
gimp_animate_anisotropic_smoothing_preview :
  -gimp_animate_preview gimp_anisotropic_smoothing,($5;$6;$7;$8;$9;$15;$16;$17;$18;$19;$20;$21;$22),($10;$11;$12;$13;$14;$15;$16;$17;$18;$19;$20;$21;$22),0

gimp_animate_anisotropic_smoothing :
  -animate gimp_anisotropic_smoothing,($5;$6;$7;$8;$9;$15;$16;$17;$18;$19;$20;$21;$22),($10;$11;$12;$13;$14;$15;$16;$17;$18;$19;$20;$21;$22),$1,$2,$3,\"$4/gmic_anisotropic_smoothing\"


#@gimp _<b>Various</b>
#----------------------

#@gimp Fourier analysis : display_fft, display_fft

#@gimp Import data : gimp_import_image, gimp_import_image
#@gimp : Filename = file()
#@gimp : Image normalization = bool(1)
#@gimp : note = note{"\n<small><b>Note : </b>
#@gimp : This filter can import any image data read by the <b>G'MIC</b> language interpreter.
#@gimp : It includes exotic formats as : <i>Pandore, CImg, Inrimage, AVI/MPEG (requires FFMPEG installed), ...</i>
#@gimp : </small>"}
gimp_import_image :
  -rm -i $1 -s z -if $2 -n 0,255 -else -c 0,255 -endif

#@gimp Custom G'MIC command : gmic_apply, gmic_apply
#@gimp : Command = text("-to_rgb --deform 20 -compose_edges 3")
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
#@gimp : note = note{"\n<small><b>Note : </b>
#@gimp : This filter can execute any set of instructions understood by the <b>G'MIC</b> language interpreter.
#@gimp : Here, you can then test some commands before creating your own G'MIC custom commands and GIMP menu entries.\n\n
#@gimp : Please look at the documentation reference web page :</small>"}
#@gimp : note = link("http://gmic.sourceforge.net/documentation.shtml")
#@gimp : note = note{"<small>
#@gimp : to learn more about available <b>G'MIC</b> commands.
#@gimp : </small>"}
gmic_apply :
  -apply \"$1\",$2

#@gimp Quick copyright : gimp_quick_copyright, gimp_quick_copyright
#@gimp : Text = text{"\251 G'MIC"}
#@gimp : Size = choice(5,"-3","-2","-1","0","+1","+2","+3","+4")
#@gimp : Color           = color(255,255,255,128)
#@gimp : Outline = int(1,0,4)
#@gimp : Position = choice(3,"Up-left","Up-right","Bottom-left","Bottom-right")
#@gimp : Offset = int(5,0,40)
#@gimp : Orientation = choice(1,"-90 deg.","0 deg.","+90 deg.","+180 deg.")
gimp_quick_copyright :
  -p {if($2==0,11,if($2==1,13,if($2==2,17,if($2==3,19,if($2==4,24,if($2==5,32,if($2==6,38,57)))))))}
  -i[0] 512,60,1,3 -text[0] $1,0,0,@{*,-1},1,$3,$4,$5 -autocrop[0] 0 -r[0] {@{0,w}+2*$7},{@{0,h}+2*$7},1,3,0,0,1
  -i[1] 512,60,1,1 -text[1] $1,0,0,@{*,-1},1,1 -autocrop[1] 0 -r[1] {@{1,w}+2*$7},{@{1,h}+2*$7},1,1,0,0,1 -dilate[1] {1+2*$7}
  -rotate[0,1] {90*($10-1)}
  -repeat {@#-2}
  -if {$8==0} -image[-1] [0],$9,$9,0,{$6/255},[1]
  -elif {$8==1} -image[-1] [0],{@{-1,w}-1-@{0,w}-$9},$9,0,{$6/255},[1]
  -elif {$8==2} -image[-1] [0],$9,{@{-1,h}-1-@{0,h}-$9},0,{$6/255},[1]
  -else -image[-1] [0],{@{-1,w}-1-@{0,w}-$9},{@{-1,h}-1-@{0,h}-$9},0,{$6/255},[1]
  -endif
  -mv[-1] 2 -done
  -rm[0,1] -pp[-1]

#@gimp _<i>Initial G'MIC filters</i>
#-----------------------------------


#@gimp About this section : nop, gimp_logo_en
#@gimp : note = note{"
#@gimp : This section contains the implementations of all the <i>initial</i> filters,
#@gimp : <i>i.e.</i> the ones defined in the stable release archive of <b>G'MIC</b>.
#@gimp : They are kept, so that in case of updating problems, the original filters are still accessible.
#@gimp : If no entries appear below, then you did probably not update your filters definitions yet."}


# Local Variables:
# mode: sh
# End:
#
# (End of G'MIC custom commands)
